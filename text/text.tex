\chapter{Introduction}
The R programming language is ubiquitous for statistical computing and data analysis, offering powerful abstraction for data manipulation and visualization. Inspired by S-Language, the R language has been important part for industries working with statistics and been pioneer for introducing widespread tools currently used by the community such as DataFrame.

Traditionally, R is an interpretered language that runs on most major operating systems.
By interpretered language, we mean that the language source code is not translated to certain binary to be executed by processor 
like compiled languages. Instead interpreter is a program, usually written in low-level languages such as C, C++  or Rust, which 
takes the source code, does lexing and parsing to get AST and directly executes the program from its AST representation by evaluating 
from top node\cite{crafting_interpreters}. Figure~\ref{r-being-interpretted} shows pipeline of R code being interpretted.

\begin{figure}[h!]
    \includegraphics[width=370px]{images/r-ast-eval-process.png}
    \caption{Example of R program being interpretered}
    \label{r-being-interpretted}
\end{figure}

% Usage of interpreter is common for dynamically typed, high-level languages like R. As dynamically typed language allows 
% programs to be written without type annotations, the type is only known in run-time by the interpreter.
% This limits certain optimization techniques but gives user minimal syntax with less conceptual overhead\cite{empirical_r_types}.

Nowadays, the industry has been expanding the environments where we can run our programs. 
The interpreter program we talked about, is traditionally compiled to bytecode, and then binary that 
the processor can execute. However, with invention of WebAssembly, we can take this interpreter
and compile it to so-called WASM bytecode, and run it on web. This is exactly what webR(cite webR) did.
This way, R code we write, can seamlessly run on the web environment on most browsers.

Compiling the interpreter to WASM introduces certain challenges. 
Since the interpreter consists of a substantial amount of code, 
every R program executed in the browser must include the entire interpreter compiled to WASM. 
This increases the overall memory footprint and can negatively impact performance, 
particularly in resource-constrained environments.

Thus, this thesis explores direct compilation of R-like language to WebAssembly. I create
subset of R with type annotations, in order to make compilation possible to WASM, as it needs static typing. Then
explore the challenges of mapping a dynamic high-level language to WASM, and finally evaluate the performance and correctness of my compiler.


\chapter{Background}

\section{The R Programming Language}

\textbf{R} is a domain-specific language designed for statistical computing and graphics, originally developed by Ross Ihaka and Robert Gentleman in the early 1990s as an open-source implementation of the \textbf{S} language. With its CRAN package manager providing more than 20000 packages, it's a widely programming language used by industries where experimenting with data is involved, such as data analytics, data mining and bio-informatics. 

\subsection{Key Characteristics}

\begin{itemize}
  \item \textbf{Dynamic typing:} Variables have no declared types; types are determined at runtime. This enables rapid prototyping but prevents static verification and certain compiler optimizations.

  \item \textbf{Vectorization:} Operations apply element-wise to vectors, matrices, and arrays. For example,
  \[
    \texttt{c(1,2,3) + c(4,5,6)} \;\Rightarrow\; \texttt{c(5,7,9)}
  \]
  without the need for explicit loops.

  \item \textbf{Lexical scoping:} R uses lexical (static) scoping with closures. Functions capture their defining environment, enabling functional programming patterns and higher-order abstractions.

  \item \textbf{Lazy evaluation:} Function arguments are evaluated lazily (call-by-need), allowing non-standard evaluation mechanisms that support domain-specific sublanguages.

  \item \textbf{Copy-on-modify semantics:} R employs implicit copying to preserve referential transparency. While this simplifies reasoning about programs, it may introduce performance overhead in memory-intensive workloads.
\end{itemize}

\subsection{Assignment Operators}

R provides multiple assignment operators with distinct scoping behavior:

\begin{itemize}
  \item \texttt{\textless{}-}: Regular assignment in the current environment.
  \item \texttt{\textless{}\textless{}-}: Superassignment, which modifies the nearest existing binding in an enclosing environment.
\end{itemize}

\subsection{Type System}
R employs a dynamic type system with several foundational types, all of which are first-class objects. Unlike statically-typed languages, type information is associated with values at runtime rather than with variable declarations.
Atomic Types
R provides six atomic vector types:
\begin{itemize}
\item \textbf{Logical:} Boolean values \texttt{TRUE}, \texttt{FALSE}, and \texttt{NA} (missing).
\begin{verbatim}
x <- TRUE
typeof(x)      # returns "logical"
\end{verbatim}
\item \textbf{Integer:} Whole numbers, denoted with an \texttt{L} suffix.
\begin{verbatim}
x <- 42L
typeof(x)      # returns "integer"
\end{verbatim}
\item \textbf{Double:} Floating-point numbers (default numeric type).
\begin{verbatim}
x <- 3.14
typeof(x)      # returns "double"
\end{verbatim}
\item \textbf{Character:} Strings of text.
\begin{verbatim}
x <- "hello"
typeof(x)      # returns "character"
\end{verbatim}
\item \textbf{Complex:} Complex numbers with real and imaginary parts.
\begin{verbatim}
x <- 2 + 3i
typeof(x)      # returns "complex"
\end{verbatim}
\item \textbf{Raw:} Raw bytes (rarely used).
\begin{verbatim}
x <- charToRaw("A")
typeof(x)      # returns "raw"
\end{verbatim}
\end{itemize}
Composite Types
Beyond atomic vectors, R supports several composite data structures:
\begin{itemize}
\item \textbf{List:} Heterogeneous collections that can hold elements of different types.
\begin{verbatim}
x <- list(42, "text", TRUE)
typeof(x)      # returns "list"
\end{verbatim}
\item \textbf{Function:} Functions are first-class objects.
\begin{verbatim}
f <- function(x) x + 1
typeof(f)      # returns "closure"
\end{verbatim}
This means functions are treated as normal variables. It can be nested definition, passed as parameter and returned from a function.
\item \textbf{Environment:} Hash-like structures for variable scoping.
\begin{verbatim}
e <- new.env()
typeof(e)      # returns "environment"
\end{verbatim}
\end{itemize}
Type Coercion
R performs implicit type coercion following a hierarchy: logical → integer → double → character. When combining types, R automatically converts to the most general type:
\begin{verbatim}
c(TRUE, 1L, 2.5, "text")  # returns character vector:
# "TRUE" "1" "2.5" "text"
\end{verbatim}
This automatic coercion simplifies interactive use but can lead to unexpected behavior if types are not carefully managed.

\subsection{Peculiarities}
As every programming language comes with their nuances and uniqueness, R is no short of those. Below, the ones mention worthy examples


\begin{itemize}
    \item Vectors and lists are indexed by 1. For example,
    \begin{verbatim}
        v <- c(10,20,30) // initializes a vector of 10,20,30
        v[1]             // returns 10
        v[2]             // returns 20
    \end{verbatim}

    \item Even a scalar is represented as a vector of 1 element. 
    \begin{verbatim}
        x <- 5           // assign 5
        is.vector(x)     // return TRUE
    \end{verbatim}
    The reason for it is to recycle the vectors easily. The language is designed for vector operations
    \begin{verbatim}
        x <- 5           // assign 5
        v <- c(10,20,30) // initializes a vector of 10,20,30
        x + v            // returns a vector of 15,25,35
    \end{verbatim}
    
\end{itemize}


\section{WebAssembly}
WebAssembly is a binary instruction format designed as a portable compilation target for high-level languages. In simpler terms, it's a bytecode format made to be a common-ground between web environment and different programming languages. For web environment, JavaScript is the only language that can be executed. However, with WebAssembly, commonly known as WASM, we can execute languages such as C, Rust in web environment after compiling them to WASM bytecode format. WASM main characteristics include:
\begin{itemize}
    \item Stack-based virtual machine: WASM uses a structured stack machine with explicit control flow constructs (block, loop, if) rather than arbitrary jumps.
    \item Linear memory: A contiguous, resizable array of bytes for heap allocation, isolated from the host environment for security.
    \item Type safety: WASM enforces type safety at validation time, preventing type confusion and memory safety violations.
\end{itemize}

