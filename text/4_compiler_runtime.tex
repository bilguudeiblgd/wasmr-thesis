\chapter{Compiler and Runtime}
\label{chapter:compiler}
This chapter describes the compiler implementation, highlighting challenges and design decisions made while compiling Typed R to WebAssembly. All implementation is written in Rust for its memory safety, modern features, and performance.

\section{Compiler Architecture}
The compiler follows a multi-pass architecture divided into front-end, middle-end, and back-end stages. The front-end transforms source code into an intermediate representation through lexical analysis, parsing, and type resolution. The middle-end performs language-independent optimizations and transformations on the IR, preparing it for efficient code generation. Finally, the back-end generates WebAssembly bytecode from the transformed IR.
Compilation begins with the lexer (\texttt{src/lexer.rs}), which tokenizes source text into a stream of tokens, recognizing R-specific operators like \texttt{<-}, \texttt{<<-}, and \texttt{:}, while tagging built-in type names as \texttt{Token::Type}. These tokens feed into the parser (\texttt{src/parser/}), which constructs an untyped Abstract Syntax Tree using recursive descent parsing\cite{recursive-descent-parser} with operator precedence. The parser handles function definitions as expressions and accepts type annotations without validating them, producing \texttt{Stmt} and \texttt{Expr} nodes defined in \texttt{src/ast.rs}.

The \texttt{TypeResolver} (\texttt{src/ir/type\_resolver.rs}) then performs scope analysis, building a scope stack where only functions create new scopes. It infers types for untyped expressions, validates type annotations and operation compatibility, and produces typed IR nodes with concrete types. The resulting IR (\texttt{src/ir/types.rs}) consists of \texttt{IRExpr} with associated \texttt{ty: Type} fields, \texttt{IRStmt} with type information, and built-in call resolution to \texttt{BuiltinKind} enum variants.

A pass manager (\texttt{src/ir/passes/manager.rs}) coordinates three transformation passes that prepare the IR for code generation. The Variable Collection Pass assigns WebAssembly local indices to all variables, tracking parameters, user variables, and compiler-generated temporaries while populating \texttt{FunctionMetadata} for each function. The Captured Variables Analysis identifies variables captured from parent scopes, computes transitive captures through nested functions, and marks variables requiring reference cells for superassignment. The Function Flattening Pass lifts nested functions to top level, replacing them with closure construction expressions and maintaining capture lists for environment building.

Finally, the backend (\texttt{src/backend/}) generates WebAssembly bytecode. The \texttt{WasmGenerator} constructs WASM module sections, registers type sections for structs, arrays, and functions, emits function code with local context tracking, and initializes memory for runtime data.

\begin{figure}[h]
\centering
\begin{tikzpicture}[
    node distance=0.8cm and 1.2cm,
    box/.style={rectangle, draw, fill=blue!10, minimum width=3cm, minimum height=0.8cm, align=center, rounded corners, font=\small},
    passbox/.style={rectangle, draw, fill=green!10, minimum width=2.4cm, minimum height=0.7cm, align=center, rounded corners, font=\scriptsize},
    arrow/.style={->, >=stealth, thick}
]

% Input
\node[font=\small\bfseries] (input) {Typed R Source Code};

% Front-end
\node[box, below=of input] (lexer) {Lexer\\{\scriptsize Token Stream}};
\node[box, below=of lexer] (parser) {Parser\\{\scriptsize Untyped AST}};
\node[box, below=of parser] (typeresolver) {Type Resolver\\{\scriptsize Typed IR}};

% Middle-end passes
\node[passbox] (capturepass) at ($(typeresolver) + (0,-1.8)$) {Captured\\Variables};
\node[passbox] (varpass) at ($(capturepass) + (-2.5,0)$) {Variable\\Collection};
\node[passbox] (flattenpass) at ($(capturepass) + (2.5,0)$) {Function\\Flattening};

% Back-end
\node[box, below=1.2cm of capturepass] (codegen) {Code Generator\\{\scriptsize WASM Bytecode}};

% Output
\node[font=\small\bfseries, below=of codegen] (output) {WebAssembly Module};

% Arrows
\draw[arrow] (input) -- (lexer);
\draw[arrow] (lexer) -- (parser);
\draw[arrow] (parser) -- (typeresolver);
\draw[arrow] (typeresolver) -- (varpass);
\draw[arrow] (typeresolver) -- (capturepass);
\draw[arrow] (typeresolver) -- (flattenpass);
\draw[arrow] (varpass) -- (codegen);
\draw[arrow] (capturepass) -- (codegen);
\draw[arrow] (flattenpass) -- (codegen);
\draw[arrow] (codegen) -- (output);

% Phase labels
\node[left=1.5cm of lexer, font=\scriptsize\itshape, text width=1.8cm, align=right] {Front-end};
\node[left=2.8cm of capturepass, font=\scriptsize\itshape, text width=1.8cm, align=right] {IR Transformation\\Passes};
\node[left=1.5cm of codegen, font=\scriptsize\itshape, text width=1.8cm, align=right] {Back-end};

\end{tikzpicture}
\caption{Typed R compiler pipeline showing the multi-pass architecture from source code through lexing, parsing, type resolution, IR transformation passes, to WebAssembly code generation}
\label{fig:compiler-pipeline}
\end{figure}

\section{WebAssembly Code Generation}
Most languages compile to WebAssembly through intermediate layers like LLVM\cite{llvm} or JVM rather than generating WebAssembly directly. This approach avoids the NÃ—M explosion problem where every language would need to support every architecture. LLVM provides a common intermediate representation that many static languages use to reach WebAssembly. Similarly, JVM-based languages gained WebAssembly support when the JVM added a WebAssembly backend. Our goal is compiling Typed R directly to WebAssembly, requiring careful mapping of R semantics to WebAssembly's type system and execution model.

Type mapping follows WebAssembly's value types: \texttt{int} maps to \texttt{i32}, \texttt{double} to \texttt{f64}, and \texttt{logical} to \texttt{i32} where 0 represents false and 1 represents true. Vectors map to \texttt{(ref \$vec\_T)}, implemented as WebAssembly GC structs containing a data array and length field. Functions map to \texttt{(ref \$functype)}, using WebAssembly's typed function references.

\begin{center}
\begin{tabular}{ll}
\hline
\textbf{Source Type} & \textbf{WebAssembly Type} \\
\hline
\texttt{int} & \texttt{i32} \\
\texttt{double} & \texttt{f64} \\
\texttt{logical} & \texttt{i32} (0 = false, 1 = true) \\
\texttt{vector<T>} & \texttt{(ref \$vec\_T)} (struct with data array and length) \\
\texttt{function} & \texttt{(ref \$functype)} (typed function reference) \\
\hline
\end{tabular}
\end{center}

Vectors are represented as WebAssembly GC structs with two fields: a mutable array for element data and a mutable integer for length:
\begin{lstlisting}[language=wat, caption={Vector struct type}]
(type $vec_f64 (struct
  (field $data (ref (array (mut f64))))
  (field $length (mut i32))
))
\end{lstlisting}

This design uses WebAssembly GC arrays for efficient storage, stores length separately for fast access, supports mutable arrays for in-place updates, and provides type-specialized structs for different element types (i32, f64, anyref). WebAssembly GC handles memory management automatically. Vectors are constructed through runtime functions and built-ins like \texttt{c}, \texttt{seq}, and \texttt{rep}.

Functions use WebAssembly typed function references. Simple functions compile to direct \texttt{(ref \$functype)} references where \texttt{\$functype} encodes the function signature. Closures require a struct containing both the function reference and the captured environment:
\begin{lstlisting}[language=wat, caption={Closure struct type}]
(type $closure (struct
  (field $func (ref $functype))
  (field $env (ref $env_struct))
))
\end{lstlisting}

Function calls use \texttt{call\_ref} for indirect calls through function references.

Literals compile to immediate value instructions: \texttt{i32.const n} for integers, \texttt{f64.const x} for floating-point, and \texttt{i32.const 0} or \texttt{i32.const 1} for booleans. Unlike R, which uses vectors even for scalar values, Typed R keeps scalar values for better performance. Variable references compile to \texttt{local.get \$var\_idx} for local variables, environment struct loads for captured variables, and \texttt{ref.func \$func\_idx} for function references.

Binary operations map to corresponding WebAssembly instructions: \texttt{i32.add}, \texttt{i32.sub}, \texttt{i32.mul} for integer arithmetic; \texttt{f64.add}, \texttt{f64.sub}, \texttt{f64.mul} for floating-point; comparison operators like \texttt{i32.eq}, \texttt{i32.lt\_s} for integers and \texttt{f64.eq}, \texttt{f64.lt} for floats; and \texttt{i32.and}, \texttt{i32.or} for logical operations with boolean normalization. Vector operations compile to loops applying scalar operations element-wise: allocate a result vector matching operand length, loop over indices, extract elements from operands, apply the scalar operation, and store results. All vector operations are written in Typed R and compiled into the runtime. For example:

\begin{lstlisting}
system_vector_add___vec_int__vec_int <- function(a: vector<int>, b: vector<int>): vector<int> {
    n <- length(a)
    m <- length(b)

    if(n != m & n %% m != 0 & m %% n != 0) {
        stop("Vector lengths not compatible for recycling")
    }

    result_len <- max(n, m)
    result: vector<int> <- vec(length=result_len, mode="int")

    for(i in 1:result_len) {
        a_idx <- ((i - 1) %% n) + 1
        b_idx <- ((i - 1) %% m) + 1
        result[i] <- a[a_idx] + b[b_idx]
    }
    return(result)
}
\end{lstlisting}
Such function is compiled to WASM and the operation vec + vec is mapped to this function name.
Function calls compile differently based on callee type. Direct calls to known functions use \texttt{call \$func\_idx}. Indirect calls through function variables load the function reference from a local or environment, evaluate arguments, then use \texttt{call\_ref \$functype\_idx}. Closure calls are more complex: load the closure struct, extract the environment and function fields, pass the environment as the first parameter followed by regular arguments, and invoke via \texttt{call\_ref \$closure\_functype\_idx}.

Conditional expressions compile to WebAssembly block structures. The \texttt{if} construct is represented as an expression that can return a value, containing a condition, then-branch, and optional else-branch. The compiler verifies at compile-time that both branches return matching types when the if-expression produces a value:
\begin{lstlisting}[language=wat, caption={If-else compilation}]
; Evaluate condition
(condition code)

; If-else structure
(if (result ...)
  (then
    ; then-branch code
    ; when expr, just leave the expr on stack
  )
  (else
    ; else-branch code
    ; when expr, just leave the expr on stack
  )
)
\end{lstlisting}

When the if-expression returns a value, it remains on the stack for the next consumer.

Assignment statements come in two forms. Regular assignment (\texttt{<-}) evaluates the right-hand side expression and stores the result using \texttt{local.set \$var\_idx}. Super-assignment (\texttt{<<-}) for captured variables evaluates the expression, loads the closure environment, navigates to the appropriate nesting level, extracts the reference cell for the variable, and updates cell contents using \texttt{struct.set}.

Loops compile straightforwardly. While loops become loop blocks with conditional branching:
\begin{lstlisting}[language=wat, caption={While loop compilation}]
(block $loop_exit
  (loop $loop_start
    ; Evaluate condition
    (condition code)

    ; Exit if false
    (i32.eqz)
    (br_if $loop_exit)

    ; Loop body
    (body code)

    ; Continue loop
    (br $loop_start)
  )
)
\end{lstlisting}

\textbf{For loops} over ranges compile to indexed loops:
\begin{lstlisting}[language=wat, caption={For loop compilation}]
; Initialize loop variable to start
(local.set $iter (start value))

(block $loop_exit
  (loop $loop_start
    ; Check condition: iter <= end
    (local.get $iter)
    (end value)
    (i32.gt_s)
    (br_if $loop_exit)

    ; Loop body with iter
    (body code)

    ; Increment iter
    (local.get $iter)
    (i32.const 1)
    (i32.add)
    (local.set $iter)

    (br $loop_start)
  )
)
\end{lstlisting}

For loops over vectors use similar structure but load vector elements by index.

\subsection{Function Compilation}
Function compilation is one of the most important. We are taking an environment 
where functions are first-class citizens to static-like function environment in WASM.

For example, how should one compile this?

\begin{lstlisting}[language=R]
        x <- 5L
        f <- function(): int {
            g <- function(): int {
                x + 1L
            }
            g()
        }
\end{lstlisting}

In WASM functions cannot be nested. So we need to propogate the environment information somehow
through the function parameters or maybe in the \texttt{Memory}. But playing with Memory, will make the implementation
much more complex. Therefore, the better is to use parameters with flattened functions. 

\begin{lstlisting}[language=wat]
        (function $g (param $x i32) result(i32) 
          local.get 0
          i32.const 1
          i32.add
          return
        )

        (function $f (param $x i32) result(i32) 
          ;; call g with param x
        )

        (function $main 
          (local $x i32)
          i32.const 5
          local.set 0
          local.get 0 ;; put x on stack
          call $f ;; call f with param x
        )
\end{lstlisting}

This is the basis for scoping and functions. Now, let's take the case, where we mutate the variable
that's outside the scope of function:

\begin{lstlisting}[language=R]
        x <- 5L
        f <- function(): int {
            g <- function(): int {
                x <<- x + 1L
                x
            }
            g()
        }
\end{lstlisting}

The variable is not only referenced but changed. However, this is not closure, the variable doesn't
outlive its scope. To solve this, I use WASM's construct \texttt{struct} from WASM GC. Then we can have a \texttt{struct} 
reference to that struct and pass it around, and then finally change it.

\begin{lstlisting}[language=wat]
        (struct $cell (field (mut i32)))
        
        (function $g (param $x (ref $cell)) result(ref $cell) 
          local.get 0
          struct.get $cell 0 ; get first field of the struct cell.
          i32.const 1
          i32.add ; add and push the result
          struct.set $cell 0 ; pop the result and set in the cell
          struct.get $cell 0 ; get updated element from the struct
          return
        )

        (function $f (param $x (ref $cell)) result(ref $cell)
          ;; call g with param x
        )

        (function $main 
          (local $x (ref $cell))
          i32.const 5
          struct.new $cell ; construct cell struct with expression on the stack.
          local.set 0 ; set the struct
          local.get 0 ;; put the struct on stack
          call $f ;; call f with param struct
        )
\end{lstlisting}

From here, we generalize this mechanism to handle true closures where functions outlive their lexical scope. The key is combining the reference cell approach with function pointers in a unified \texttt{env} struct. This structure contains both the captured variables we want to pass and modify, as well as a function pointer that allows us to call the closure later. By packaging these together, we create a closure representation that WebAssembly can work with efficiently.

The closure compilation strategy leverages structural subtyping to maintain type safety. We define a base environment type that all closures share, containing only the function pointer field. Each specific closure then defines a concrete environment type that extends this base with its particular captured variables. This approach allows closures with different capture sets to share a common interface while preserving their unique environments.

\begin{lstlisting}[language=wat, caption={Base and concrete environment types}]
(type $env_base (struct
  (field $func_ptr (ref $closure_func_ty))))

(type $env_concrete (sub $env_base (struct
  (field $func_ptr (ref $closure_func_ty))
  (field $captured_x i32)
  (field $captured_y f64))))
\end{lstlisting}

Consider a typical scenario where an outer function returns an inner function that captures local variables. The compiler analyzes which variables the inner function references, then generates a concrete environment struct type with fields for each captured variable. When the closure is created at runtime, the compiler emits code to allocate the environment struct, initialize its fields with current values of captured variables, and store the function pointer in the first field. The result is a reference to this struct, which serves as the closure value itself.

When a closure is invoked, accessing the captured variables requires a downcast. The function receives the environment as its first parameter typed as the base environment reference, but to access specific captured variable fields, the compiler must downcast it to the concrete environment type. WebAssembly validates this downcast at runtime, ensuring type safety. The function pointer stored in the environment allows indirect calls via \texttt{call\_ref}, passing the environment as the first argument so the function can access its captures.

\begin{lstlisting}[language=wat, caption={Closure accessing captured variables}]
(type $env_concrete (struct
  (field $func_ptr (ref $closure_func_ty))
  (field $captured_x i32)))

(func $closure_body (param $env (ref $env_base)) (param $y i32) (result i32)
  (local $concrete_env (ref $env_concrete))

  ; Downcast to concrete type
  (local.set $concrete_env
    (ref.cast (local.get $env) (ref $env_concrete)))

  ; Access captured variable
  (struct.get $env_concrete $captured_x (local.get $concrete_env))
  (local.get $y)
  (i32.add)
)
\end{lstlisting}

For simple functions that capture no variables, compilation is more straightforward. The compiler registers the function type in the type section, allocates a unique function index, determines local variable slots from the function's metadata, and emits the function body directly. These functions require no environment parameter and compile to efficient direct calls.

\begin{lstlisting}[language=wat, caption={Simple function without captures}]
(func $add (param $a i32) (param $b i32) (result i32)
  (local.get $a)
  (local.get $b)
  (i32.add)
)
\end{lstlisting}

The complete function compilation process integrates type registration, closure analysis, environment struct generation, and code emission into a cohesive pipeline. For each function, the compiler identifies whether it captures variables from outer scopes through static analysis. If captures exist, it generates an appropriate environment struct type and modifies the function signature to accept the environment as its first parameter. The function body is then emitted with additional instructions to downcast the environment and access captured variables through struct field accesses. When a function is returned as a closure value, the compiler generates code to construct the environment struct at the return site, populate it with the current values of captured variables, store the function pointer in the first field, and return the struct reference representing the closure.

\section{Runtime System}

The runtime leverages WebAssembly GC for automatic memory management, treating vectors, and closures as GC-managed heap objects. This eliminates the need for explicit deallocation, as WebAssembly GC handles reference counting and garbage collection automatically. Linear memory is reserved for WASI I/O buffers and string serialization. The memory layout reserves address 0 for null pointer checks, allocates addresses from 8 onward for WASI I/O buffers used by \texttt{fd\_write}, and maintains a dynamic region managed by the compiler for temporary string buffers.

Vector construction through \texttt{c(...)} determines the element type from arguments, allocates an array of appropriate size, initializes array elements, allocates the vector struct, stores the array reference and length, and returns the vector struct reference. Component-wise vector arithmetic is implemented as inline loops for performance rather than runtime calls, as described earlier. Reduction operations are simpler: \texttt{length} extracts and returns the length field from the vector struct, while \texttt{sum} loops over vector elements to accumulate their sum.

The \texttt{print} function handles output by serializing values to strings and calling WASI. It converts the value to its string representation, writes the string to a linear memory buffer, then calls \texttt{fd\_write} to output to stdout (file descriptor 1). Different types require different serialization: integers and floats convert to decimal strings (with precision for floats), strings output directly, vectors format as \texttt{[elem1, elem2, ...]}, and booleans output as \texttt{TRUE} or \texttt{FALSE}.

Sequence generation through the range operator \texttt{start:end} or \texttt{gen\_seq} function calculates the sequence length as \texttt{end - start + 1}, allocates a vector of integers, fills the array with values from start to end, and returns the vector struct. The implementation uses a simple loop without intermediate allocations for efficiency.

WASI integration provides I/O capabilities through the WebAssembly System Interface. The runtime imports \texttt{fd\_write} from \texttt{wasi\_snapshot\_preview1} with signature \texttt{(i32, i32, i32, i32) -> i32}, accepting parameters for file descriptor, iovs pointer, iovs length, and nwritten pointer. This enables output to stdout and stderr. The exported \texttt{\_start} function serves as the entry point, maintaining compatibility with WASI runtimes like Wasmtime.

Moreover, we have two ways to extend our runtime. Either add inline WASM code in the source code, like how \texttt{print} works, or
write Typed R program, which will be compiled and embedded into the top of the generated WASM code. The latter simplifies the implementation and 
makes it easy to extend our runtime. For mathematicals, and library functions, we can just write Typed R program and they'll be compiled to WASM as runtime.
\section{Implementation Details}

\subsection{Compilation Limitations}

The current implementation represents a proof-of-concept compiler with several deliberate limitations. Most notably, the compiler lacks any exception or error handling mechanism, meaning runtime errors simply terminate execution without graceful recovery. The standard library remains minimal, providing only essential built-in functions like \texttt{print}, \texttt{length}, \texttt{sum}, and vector construction. I/O capabilities are restricted to print output via WASI; file operations and user input are not supported. Type coercion is limited compared to R's flexible type system, supporting only the basic numeric promotion hierarchy (logical $<:$ int $<:$ double). Vector operations cover common arithmetic and indexing but lack many of R's specialized functions like \texttt{apply}, \texttt{sapply}, or statistical operations. List types, while declared in the type system, remain largely unimplemented in the code generator.

\subsection{Design Decisions}

Several architectural decisions shaped the compiler's implementation, each involving trade-offs between performance, simplicity, and compatibility with R semantics. The choice of static typing fundamentally enables efficient ahead-of-time compilation and early error detection, though at the cost of R's dynamic flexibility. This trade-off aligns with the thesis goal of exploring compilation rather than interpretation.

Memory management leverages the WebAssembly GC proposal, which simplifies object lifecycle management and enables efficient heap object representation without manual deallocation. This choice requires newer WebAssembly runtimes but eliminates the complexity of implementing a custom garbage collector or reference counting system. The scoping model follows R's semantics where only functions create scopes while blocks, if-statements, and loops share their enclosing function's scope. This design simplifies closure implementation by avoiding the need to track block-level environments.

For function calls, the compiler uses typed function references rather than function tables. Typed funcrefs enable type-safe indirect calls and eliminate table management overhead, though this feature requires WebAssembly reference types support. Closures are represented as structs containing a function reference and captured environment, providing cleaner semantics than stack manipulation approaches. Variables captured with super-assignment semantics use reference cells (GC structs wrapping mutable values), enabling efficient updates through multiple closure layers.

Vector operations are inlined as loops rather than compiled to runtime function calls. While this increases code size, it improves performance for common element-wise operations by avoiding function call overhead and enabling better optimization by the WebAssembly runtime.

The implementation relies on two key tools: wasm-encoder for code generation and Wasmtime for execution. The wasm-encoder library (part of the wasm-tools project) provides a programmatic API for constructing WebAssembly modules in Rust. Unlike alternatives such as writing WebAssembly Text Format (WAT) and assembling with wat2wasm, or using the older parity-wasm library, wasm-encoder offers type-safe module construction with strong guarantees about validity, making it easier to generate correct bytecode. The library's design matches naturally with Rust's type system, reducing the likelihood of encoding errors.

For runtime execution and testing, Wasmtime serves as the WebAssembly runtime engine. Wasmtime, maintained by the Bytecode Alliance, implements the latest WebAssembly specifications including the GC proposal, WASI, and component model. Alternatives like Wasmer or browser-based runtimes were considered, but Wasmtime provides the most mature support for WebAssembly GC, which is essential for this compiler's memory management strategy. Its command-line interface simplifies testing during development, and its Rust embedding API enables potential integration with higher-level tooling. Wasmtime's focus on security, standards compliance, and performance makes it well-suited for both development and production use.

\subsection{Performance Considerations}

The compiler employs several optimization strategies to generate efficient WebAssembly code. Type specialization creates separate vector struct types for i32, f64, and anyref element types, avoiding runtime type checks and enabling more efficient memory layouts. When function call targets are known at compile time, the compiler generates direct \texttt{call} instructions rather than slower indirect \texttt{call\_ref} instructions, reducing call overhead significantly.

Local variable allocation reuses slots for temporary variables when their lifetimes don't overlap, minimizing the function's local declaration section and potentially improving WebAssembly JIT compilation. As discussed earlier, component-wise vector operations are inlined as loops rather than calling runtime functions, trading code size for execution speed. The compiler also caches function signature type indices to avoid recreating identical types in the WebAssembly type section, reducing module size and improving instantiation time. These optimizations focus on low-hanging fruit that provide measurable benefits without requiring complex analysis passes.

