@book{Crochemore2002,
  author        = {Maxime Crochemore and Wojciech Rytter},
  title         = {Jewels of stringology},
  publisher     = {World Scientific},
  address       = {Ri\-ver Edge, NJ},
  year          = {2002},
  isbn          = {978-9810247829},
}

@book{Motwani2014,
  author        = {Rajeev Motwani and Jeffrey D. Ullman and John E. Hopcroft},
  title         = {Introduction to automata theory, languages, and computation},
  publisher     = {Pearson},
  address       = {Harlow},
  year          = {2014},
  edition       = {Third},
  ISBN          = {9781292039053},
}



@inproceedings{def:2,
	author       = {Leonid Libkin},
	year         = {2005},
	isbn         = {978-3-540-27580-0},
	booktitle    = {Automata, Languages and Programming},
	volume       = {3580},
	series       = {Lecture Notes in Computer Science},
	editor       = {Caires, Luís and Italiano, Giuseppe and Monteiro, Luís and Palamidessi, Catuscia and Yung, Moti},
	title        = {Logics for Unranked Trees: An Overview},
	publisher    = {Springer Berlin Heidelberg},
	pages        = {35--50},
}

@inproceedings{def:1,
	author       = {Frank Neven},
	year         = {2002},
	isbn         = {978-3-540-44240-0},
	booktitle    = {Computer Science Logic},
	volume       = {2471},
	series       = {Lecture Notes in Computer Science},
	editor       = {Bradfield, Julian},
	title        = {Automata, Logic, and XML},
	publisher    = {Springer Berlin Heidelberg},
	pages        = {2--26},
}

@misc{darkMode,
	author = {TopDevelopers.co},
  title = {Light Mode Vs. Dark Mode -- What\'s Your Choice For UX? | by TopDevelopers.co | Medium},
  year = {2024},
  howpublished = {[Online]},
  url = {https://medium.com/@topdevelopers-co/light-mode-vs-dark-mode-whats-your-choice-for-ux-5bce3ad4a368},
  note = {[Accessed: 2025-02-27]}
}

@inproceedings{webassembly,
  title={Bringing the web up to speed with WebAssembly},
  author={Haas, Andreas and Rossberg, Andreas and Schuff, Derek L and Titzer, Ben L and Holman, Michael and Gohman, Dan and Wagner, Luke and Zakai, Alon and Bastien, JF},
  booktitle={Proceedings of the 38th ACM SIGPLAN conference on programming language design and implementation},
  pages={185--200},
  year={2017},
  isbn={978-1-4503-4988-8}
}

@book{crafting_interpreters,
  author    = {Nystrom, Robert},
  title     = {{Crafting Interpreters}},
  year      = {2021},
  publisher = {Genever Benning},
  isbn      = {978-0990582939},
  url       = {https://craftinginterpreters.com/}
}

@article{empirical_r_types,
author = {Turcotte, Alexi and Goel, Aviral and K\v{r}ikava, Filip and Vitek, Jan},
title = {Designing types for R, empirically},
year = {2020},
issue_date = {November 2020},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {4},
number = {OOPSLA},
url = {https://doi.org/10.1145/3428249},
doi = {10.1145/3428249},
abstract = {The R programming language is widely used in a variety of domains. It was designed to favor an interactive style of programming with minimal syntactic and conceptual overhead. This design is well suited to data analysis, but a bad fit for tools such as compilers or program analyzers. In particular, R has no type annotations, and all operations are dynamically checked at run-time. The starting point for our work are the two questions: what expressive power is needed to accurately type R code? and which type system is the R community willing to adopt? Both questions are difficult to answer without actually experimenting with a type system. The goal of this paper is to provide data that can feed into that design process. To this end, we perform a large corpus analysis to gain insights in the degree of polymorphism exhibited by idiomatic R code and explore potential benefits that the R community could accrue from a simple type system. As a starting point, we infer type signatures for 25,215 functions from 412 packages among the most widely used open source R libraries. We then conduct an evaluation on 8,694 clients of these packages, as well as on end-user code from the Kaggle data science competition website.},
journal = {Proc. ACM Program. Lang.},
month = nov,
articleno = {181},
numpages = {25},
keywords = {R, dynamic languages, type declarations}
}

@misc{rbytecodebook,
  author = {Henderson, Mike},
  title = {R Bytecode Book},
  year = {2020},
  howpublished = {[Online]},
  url = {https://coolbutuseless.github.io/book/rbytecodebook/},
  note = {[Accessed: 2025-12-28]},
}

@software{webR,
  author = {{RStudio, PBC}},
  title = {webR},
  version = {1.0},
  year = {2023},
  howpublished = {[Online]},
  url = {https://webr.rstudio.com},
  note = {[Accessed: 2025-12-28]}
}

@misc{mdn_webassembly,
  author = {{MDN Web Docs}},
  title = {{WebAssembly}},
  year = {2025},
  howpublished = {[Online]},
  url = {https://developer.mozilla.org/en-US/docs/WebAssembly},
  note = {[Accessed: 2025-12-28]}
}

@misc{figma_wasm,
  author = {Evan Wallace},
  title = {{WebAssembly cut Figma's load time by 3x}},
  year = {2017},
  howpublished = {[Online]},
  url = {https://www.figma.com/blog/webassembly-cut-figmas-load-time-by-3x/},
  note = {[Accessed: 2025-12-28]}
}

@misc{autocad_wasm,
  author={Aaron Turner},
  title={{AutoCAD Web App}},
  year = {2019},
  howpublished = {[Online]},
  url={https://madewithwebassembly.com/showcase/autocad/},
  note = {[Accessed: 2025-12-28]}
}

@misc{google_earth_wasm,
  author={Jordon Mears},
  title={{How we're bringing Google Earth to the web}},
  year = {2019},
  howpublished = {[Online]},
  url={https://web.dev/case-studies/earth-webassembly/},
  note = {[Accessed: 2025-12-28]}
}

@report{wasm_specs,
  author = {Rossberg, Andreas},
  title = {{{WebAssembly Core Specification}}},
  institution = {{W3C}},
  year = {2019},
  howpublished = {[Online]},
  url = {https://www.w3.org/TR/wasm-core-1/},
  note = {[Accessed: 2025-12-28]}
}

@article{r_paper,
  title={R: A language for data analysis and graphics},
  author={Ihaka, Ross and Gentleman, Robert},
  journal={Journal of Computational and Graphical Statistics},
  volume={5},
  number={3},
  pages={299--314},
  year={1996},
  publisher={Taylor \& Francis},
  issn={1061-8600}
}

@misc{r_version_213_notes,
  author={Eddelbuettel, Dirk},
  title={The new R compiler package in R 2.13.0: Some first experiments},
  year = {2011},
  howpublished = {[Online]},
  url={https://www.r-bloggers.com/2011/04/the-new-r-compiler-package-in-r-2-13-0-some-first-experiments/},
  note = {[Accessed: 2025-12-28]}
}

@inproceedings{tierney2019bytecode,
  title={The R bytecode compiler and VM},
  author={Tierney, Luke},
  booktitle={RIOT 2019: R Implementation, Optimization and Tooling Workshop},
  year={2019},
  address={Toulouse, France},
  url={https://homepage.divms.uiowa.edu/~luke/talks/Riot-2019.pdf}
}

@article{RJ-2017-1-ch,
  author = {Team, The R Core},
  title = {Changes in R},
  journal = {The R Journal},
  year = {2017},
  note = {https://journal.r-project.org/news/RJ-2017-1-ch},
  volume = {9},
  issue = {1},
  issn = {2073-4859},
  pages = {509-521}
}

@inproceedings{R_towards_type_system,
author = {Turcotte, Alexi and Vitek, Jan},
title = {Towards a Type System for R},
year = {2019},
isbn = {9781450368629},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3340670.3342426},
doi = {10.1145/3340670.3342426},
abstract = {R is a fascinating language: It is dynamically typed, vectorized, both lazy and side-effecting, and it fosters an interactive style of programming. This unique combination of features makes it easy to use, but prone to errors and strange behaviour. R is the tool of choice for many data analysts, and our aim is to empower them with a language that is not simply easy to use, but easy to use well, so as to increase their confidence in the data analyses they undertake. To that end, we are developing a type system for R that is simple enough to be attractive to programmers while being expressive enough to capture existing programming paradigms. In this paper, we outline past, present, and future work as we build up to a type system for R.},
booktitle = {Proceedings of the 14th Workshop on Implementation, Compilation, Optimization of Object-Oriented Languages, Programs and Systems},
articleno = {4},
numpages = {5},
location = {London, United Kingdom},
series = {ICOOOLPS '19}
}

@misc{typr2025,
  author = {{WeData}},
  title = {{TypR}: {R}'s Types for Data Sciences},
  year = {2025},
  howpublished = {[Online]},
  url = {https://we-data-ch.github.io/typr.github.io/},
  note = {[Accessed: 2025-12-30]}
}

@book{types_and_pl,
  title={Types and Programming Languages},
  author={Pierce, Benjamin C.},
  year={2002},
  publisher={MIT Press},
  isbn={978-0-262-16209-8}
}

@article{bidirectional_typing,
author = {Dunfield, Jana and Krishnaswami, Neel},
title = {Bidirectional Typing},
year = {2021},
issue_date = {June 2022},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {54},
number = {5},
issn = {0360-0300},
url = {https://doi.org/10.1145/3450952},
doi = {10.1145/3450952},
abstract = {Bidirectional typing combines two modes of typing: type checking, which checks that a program satisfies a known type, and type synthesis, which determines a type from the program. Using checking enables bidirectional typing to support features for which inference is undecidable; using synthesis enables bidirectional typing to avoid the large annotation burden of explicitly typed languages. In addition, bidirectional typing improves error locality. We highlight the design principles that underlie bidirectional type systems, survey the development of bidirectional typing from the prehistoric period before Pierce and Turner’s local type inference to the present day, and provide guidance for future investigations.},
journal = {ACM Comput. Surv.},
month = may,
articleno = {98},
numpages = {38},
keywords = {Type checking, type inference}
}

@inproceedings{llvm,
author = {Lattner, Chris and Adve, Vikram},
title = {LLVM: A Compilation Framework for Lifelong Program Analysis \& Transformation},
year = {2004},
isbn = {0769521029},
publisher = {IEEE Computer Society},
address = {USA},
abstract = {This paper describes LLVM (Low Level Virtual Machine),a compiler framework designed to support transparent, lifelongprogram analysis and transformation for arbitrary programs,by providing high-level information to compilertransformations at compile-time, link-time, run-time, and inidle time between runs.LLVM defines a common, low-levelcode representation in Static Single Assignment (SSA) form,with several novel features: a simple, language-independenttype-system that exposes the primitives commonly used toimplement high-level language features; an instruction fortyped address arithmetic; and a simple mechanism that canbe used to implement the exception handling features ofhigh-level languages (and setjmp/longjmp in C) uniformlyand efficiently.The LLVM compiler framework and coderepresentation together provide a combination of key capabilitiesthat are important for practical, lifelong analysis andtransformation of programs.To our knowledge, no existingcompilation approach provides all these capabilities.We describethe design of the LLVM representation and compilerframework, and evaluate the design in three ways: (a) thesize and effectiveness of the representation, including thetype information it provides; (b) compiler performance forseveral interprocedural problems; and (c) illustrative examplesof the benefits LLVM provides for several challengingcompiler problems.},
booktitle = {Proceedings of the International Symposium on Code Generation and Optimization: Feedback-Directed and Runtime Optimization},
pages = {75},
location = {Palo Alto, California},
series = {CGO '04}
}

@Inbook{recursive-descent-parser,
author="van de Snepscheut, Jan L. A.",
title="Recursive Descent Parsing",
bookTitle="What Computing Is All About",
year="1993",
publisher="Springer New York",
address="New York, NY",
pages="101--120",
abstract="We have encountered grammars a number of times. We started our discussions of what a computation is by looking at grammars. We defined languages by devising grammars for defining them. We translated right-linear grammars into transition graphs and then into VLSI circuits. In this chapter, we study programs for parsing input strings, that is, programs that determine whether a given input string can be derived from a given grammar. In the case of right-linear grammars, we had a severe restriction on the grammar: every rule has a left-hand side of exactly one nonterminal and a right-hand side of a sequence of zero or more terminals followed by at most one nonterminal. This restriction corresponds to finite machines. In this chapter, the restriction is less severe. The left-hand side is still restricted to be one nonterminal but the right-hand side is unrestricted. This class of grammars is called the class of context-free grammars. Later on, we have to impose further restrictions to admit efficient parsing algorithms; in fact, we discuss only one parsing strategy. This strategy is called top-down parsing. We give an implementation in the form of a set of recursive procedures, and then the parsing method is sometimes referred to as parsing by recursive descent. This method is limited to grammars that satisfy the LL(1) condition, which is discussed later. We begin by discussing the parsing method in the context of the domino game, and we have a look at its implementation in the form of a set of recursive procedures. We explore the theoretical limitations, and we discuss ways of improving the practical feasibility of this method.",
isbn="978-1-4612-2710-6",
doi="10.1007/978-1-4612-2710-6_6",
url="https://doi.org/10.1007/978-1-4612-2710-6_6"
}


