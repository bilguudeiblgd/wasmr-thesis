
\chapter{Language Design and Type System}
In this chapter, we'll design a subset of R with types and see how types and their operations could map to WASM generation.
\section{Design Goals}
Some reader at this point might be wondering why subset of R and why with types, why not just compile R to WASM. 
R is notoriously hard to compile to statically typed byte-code. A first reason is typing. 
\newline

\subsection{What makes R hard to compile}
\paragraph{Dynamic typing}
Let's take the following code.
\begin{lstlisting}
  x <- some_function()
\end{lstlisting}
WASM on the other hand is expecting variable \texttt{x} to have a type. There's 
\texttt{any} type in WASM. Maybe we can try mapping it to \texttt{anyref}. A reference to \texttt{any} element by the WASM GC proposal.
So now we have
\begin{lstlisting}
  (local $x anyref) // A tagged union can be also used.
\end{lstlisting}
Then, let's have a binary operation \texttt{x + y}, where \texttt{y} is also \texttt{anyref}.
Now we need to implement a generic function for plus operator that can potentially dispatch to all types of that function.
\begin{lstlisting}
  if x is int && y is int:
    add_int(x, y)
  if x is double && y is double:
    add_double(x, y)
  ...
\end{lstlisting}
This code will continue for every type and its combination. We'd have to also include promotion logic 
inside this code. Then x is int needs \texttt{try\_cast} as well. 
We'll need to do such generic function for every operation and functions. Some will be 
impossible to cover. This is essentially re-implementing the R interpreter.
Thus we fixate on R that's well-typed and the type is known or inferrable at compile time.

Moreover, we will see the same issue of dynamic dispatching when R variables change types.
\begin{lstlisting}
  x <- 5        # numeric
  x <- "hello"  # now a string
  x <- list()   # now a list
\end{lstlisting}
This bounds us to either writing generic functions or using wrappers like a tagged union, which will 
limit our performance and waste memory.

\paragraph{Changes in Runtime}
Change in built-in functions.
\begin{lstlisting}
  `+` <- function(x, y) x * y  # redefine addition!
\end{lstlisting}
This makes the job of compiler very hard.

\paragraph{Lazy Evaluation}
R uses lazy evaluation for function arguments; they're only evaluated when actually used:
\begin{lstlisting}
  f <- function(x, y) { if (x > 0) y else 0 }
  f(5, expensive_computation())  # expensive_computation() never runs!
\end{lstlisting}
This requires complex bookkeeping that's hard to optimize.

\paragraph{Reflection and Metaprogramming}
R code can inspect and modify itself at runtime:
\begin{lstlisting}
  x <- quote(a + b)  # capture unevaluated expression
  eval(x)            # evaluate it later
\end{lstlisting}

\paragraph{Non-Standard Evaluation (NSE)}
Many R functions evaluate arguments in non-standard ways:
\begin{lstlisting}
  subset(df, age > 30)  # 'age' isn't a variable, it's a column name!
\end{lstlisting}
This is extremely difficult to analyze statically.

In conclusion, all those issues outlined above, is not impossible to compile. However, they require
complex implementation and huge performance and memory trade-offs. For these, reasons it's important
for me to define the subset of R, which I can compile and limit the scope without losing R's main functionalities and purposes.

\section{Typed R-like Language}
This section presents the design of a statically-typed programming language inspired by R's syntax, which we refer to as the \textit{Typed R-like Language}. The language maintains R's characteristic features such as the left-assignment operator (\texttt{<-}), first-class functions, and vector-oriented programming, while introducing a static type system to enable ahead-of-time compilation to WebAssembly.
Below is table \ref{tab:r-typed-r-comparison0} comparing R and typed R in terms of features and design.

\begin{table}[h]
\centering
\begin{tabular}{|l|c|c|}
\hline
\textbf{Language Feature (Types)} & \textbf{R} & \textbf{Typed R} \\
% Basic Data Types
\hline
Integers & \checkmark & \checkmark \\
Doubles & \checkmark & \checkmark \\
Booleans & \checkmark & \checkmark \\
Strings & \checkmark & $\times$ \\
NULL/NA values & \checkmark & $\times$ \\
\hline

% Composite Data Types
Vectors & \checkmark & \checkmark \\
Matrices & \checkmark & $\times$ \\
Lists & \checkmark & $\times$ \\
Data frames & \checkmark & $\times$ \\
Arrays & \checkmark & $\times$ \\
\hline
\end{tabular}
\caption{Comparison of language features supported by R and Typed R}
\label{tab:r-typed-r-comparison0}
\end{table}

\begin{table}[h]
\centering
\begin{tabular}{|l|c|c|}
\hline
\textbf{Language Feature} & \textbf{R} & \textbf{Typed R} \\
% Basic Data Types
\hline

Static typing & $\times$ & \checkmark \\
First-class functions & \checkmark & \checkmark \\
Vector operations & \checkmark & \checkmark \\
Math operations & \checkmark & \checkmark \\
Control flow & \checkmark & \checkmark \\
Higher-order functions & \checkmark & \checkmark \\
Lexical scoping & \checkmark & \checkmark \\
Named arguments & \checkmark & \checkmark \\
Variable arguments (...) & \checkmark & \checkmark \\
\hline
Reflection & \checkmark & $\times$ \\
Runtime type changes & \checkmark & $\times$ \\
Non-standard evaluation (NSE) & \checkmark & $\times$ \\
Lazy evaluation & \checkmark & $\times$ \\
Copy-on-modify semantics & \checkmark & $\times$ \\
Garbage collection & \checkmark & \checkmark \\
Operator overloading & \checkmark & $\times$  \\
Attributes/metadata & \checkmark & $\times$  \\
Method dispatch (S3/S4/R6) & \checkmark & $\times$  \\

\hline
\end{tabular}
\caption{Comparison of language types supported by R and Typed R}
\label{tab:r-typed-r-comparison1}
\end{table}

The design philosophy emphasizes a familiar R-like syntax while ensuring type safety and efficient compilation to WebAssembly. Unlike dynamically-typed R, all type information is resolved at compile time, enabling optimized code generation and early error detection.

\section{Syntax}

The syntax of the Typed R-like Language closely follows R conventions with extensions for explicit type annotations. This section describes the core syntactic constructs.

\paragraph{Examples of Typed R}

\subparagraph{Variable Declaration and Assignment}

Variables are declared using the left-assignment operator with optional type annotations:

\begin{lstlisting}[language=R, caption={Variable assignment examples}]
# Simple assignment with type inference
x <- 10

# Assignment with explicit type annotation
y: int <- 20

# Vector assignment
vec <- c(1, 2, 3)
\end{lstlisting}

% \begin{lstlisting}[caption={Variable assignment in WAT}]
% (module
%   ;; Define array type for vectors
%   (type $vec_i32 (array (mut i32)))
  
%   (func $main
%     (local $x i32)
%     (local $y i32)
%     (local $vec (ref null $vec_i32))
    
%     ;; x <- 10
%     i32.const 10
%     local.set $x
    
%     ;; y: int <- 20
%     i32.const 20
%     local.set $y
    
%     ;; vec <- c(1, 2, 3)
%     i32.const 1
%     i32.const 2
%     i32.const 3
%     i32.const 3
%     array.new_fixed $vec_i32 3
%     local.set $vec
%   )
  
%   (start $main)
% )
% \end{lstlisting}

\subparagraph{Variable super-assignment}
The super-assignment operator \texttt{<<-} modifies variables in enclosing function scopes:

\begin{lstlisting}[language=R, caption={Super-assignment example}]
outer <- function() {
    x <- 0
    inner <- function() {
        x <<- 10  # Modifies x in outer scope
    }
    inner()
    return(x)  # Returns 10
}
\end{lstlisting}
\textit{In this case we see that it's identical to its R version}


\subparagraph{Function Definitions}

Functions are first-class values defined using the \texttt{function} keyword:

\begin{lstlisting}[language=R, caption={Function definition examples in typed R}]
# Simple function with type annotations
add <- function(a: int, b: int): int {
    return(a + b)
}

# Function returning a vector
create_vector <- function(): vector<double> {
    return(c(1.0, 2.0, 3.0))
}

# Higher-order function
apply_twice <- function(f: int -> int, x: int): int {
    return(f(f(x)))
}

\end{lstlisting}

% \begin{lstlisting}[caption={Function definition examples in WAT}]
% (module
%   ;; Define array type for double vectors
%   (type $vec_f64 (array (mut f64)))
  
%   ;; add <- function(a: int, b: int): int
%   (func $add (param $a i32) (param $b i32) (result i32)
%     local.get $a
%     local.get $b
%     i32.add
%   )
  
%   ;; create_vector <- function(): vector<double>
%   (func $create_vector (result (ref $vec_f64))
%     f64.const 1.0
%     f64.const 2.0
%     f64.const 3.0
%     i32.const 3
%     array.new_fixed $vec_f64 3
%   )
%   ;; apply_twice is not shown here.
  
% )
% \end{lstlisting}

\subparagraph{Conditional Statements}

The language supports \texttt{if-else} statements and expressions:

\begin{lstlisting}[language=R, caption={Conditional examples in typed R}]
# If statement
if (x > 0) {
    print(x)
}

# If-else statement
if (x > 0) {
    y <- 1
} else {
    y <- -1
}

# If expression (returns value)
result <- if (x > 0) { 1 } else { -1 }
\end{lstlisting}

% \begin{lstlisting}[caption={Conditional examples in WAT}]
% (module
%   ;; Import print function from host environment
%   (import "env" "print" (func $print (param i32)))
  
%   (func $main
%     (local $x i32)
%     (local $y i32)
    
%     ;; Set x to some value for demonstration
%     i32.const 5
%     local.set $x
    
%     ;; if (x > 0) { print(x) }
%     local.get $x
%     i32.const 0
%     i32.gt_s              ;; x > 0 (signed comparison)
%     if
%       local.get $x
%       call $print
%     end
    
%     ;; if (x > 0) { y <- 1 } else { y <- -1 }
%     local.get $x
%     i32.const 0
%     i32.gt_s              ;; x > 0
%     if
%       i32.const 1
%       local.set $y
%     else
%       i32.const -1
%       local.set $y
%     end
%   )
  
%   (start $main)
% )
% \end{lstlisting}

\subparagraph{Loops}

Two loop constructs are provided: \texttt{for} and \texttt{while}.

\begin{lstlisting}[language=R, caption={Loop examples}]
# For loop iterating over range
for (i in 1:10) {
    print(i)
}

# For loop iterating over vector
vec <- c(1, 2, 3, 4, 5)
for (x in vec) {
    print(x)
}

# While loop
i <- 1
sum <- 0
while (i <= 5) {
    sum <- sum + i
    i <- i + 1
}
\end{lstlisting}

% \begin{lstlisting}[caption={While loop examples in WAT}]
% (module
%   (func $main
%     (local $i i32)
%     (local $sum i32)
    
%     ;; i <- 1
%     i32.const 1
%     local.set $i
    
%     ;; sum <- 0
%     i32.const 0
%     local.set $sum
    
%     ;; while (i <= 5) { ... }
%     (block $break
%       (loop $continue
%         ;; Check condition: i <= 5
%         local.get $i
%         i32.const 5
%         i32.le_s            ;; i <= 5 (signed comparison)
%         i32.eqz             ;; negate: if NOT (i <= 5)
%         br_if $break        ;; break if condition is false
        
%         ;; sum <- sum + i
%         local.get $sum
%         local.get $i
%         i32.add
%         local.set $sum
        
%         ;; i <- i + 1
%         local.get $i
%         i32.const 1
%         i32.add
%         local.set $i
        
%         ;; Continue loop
%         br $continue
%       )
%     )
%   )
  
%   (start $main)
% )
% \end{lstlisting}


\subparagraph{Blocks and Tail Expressions}

Blocks consist of zero or more statements followed by an optional tail expression. The tail expression (final expression without semicolon) determines the block's value:

\begin{lstlisting}[language=R, caption={Block with tail expression}]
f <- function(x: int): int {
    y <- x * 2
    z <- y + 1
    z  # Tail expression - returned automatically
}
\end{lstlisting}

\subsection{Abstract Grammar}


\paragraph{Types}
\begin{align*}
\tau ::= &\ \texttt{int} \mid \texttt{double} \mid \texttt{char} \mid \texttt{logical} \mid \texttt{void} \\
    &\mid \texttt{vector}\langle\tau\rangle \\
    &\mid \texttt{list} \\
    &\mid \tau_1, \ldots, \tau_n \to \tau \quad \text{(function types)}
\end{align*}

\paragraph{Expressions}
\begin{align*}
e ::= &\ x \quad \text{(variable)} \\
    &\mid n \mid d \mid \texttt{true} \mid \texttt{false} \quad \text{(literals)} \\
    &\mid \texttt{function}(p_1, \ldots, p_n): \tau\ \{\ e\ \} \quad \text{(function definition)} \\
    &\mid e_1(e_2, \ldots, e_n) \quad \text{(function call)} \\
    &\mid e_1(x_1{=}e_2, \ldots, x_n{=}e_n) \quad \text{(named argument call)} \\
    &\mid e_1 \oplus e_2 \quad \text{(binary operation)} \\
    &\mid \ominus e \quad \text{(unary operation)} \\
    &\mid \texttt{c}(e_1, \ldots, e_n) \quad \text{(vector construction)} \\
    &\mid e_1:e_2 \quad \text{(range sequence)} \\
    &\mid e_1[e_2] \quad \text{(vector indexing)} \\
    &\mid \texttt{if}\ e_1\ \{\ e_2\ \}\ \texttt{else}\ \{\ e_3\ \} \quad \text{(conditional)} \\
    &\mid \{\ e_1;\ \ldots;\ e_n\ \} \quad \text{(block)}
\end{align*}

\paragraph{Statements}
\begin{align*}
s ::= &\ x \gets e \quad \text{(assignment)} \\
    &\mid x: \tau \gets e \quad \text{(typed assignment)} \\
    &\mid x \ll\gets e \quad \text{(superassignment)} \\
    &\mid e \quad \text{(expression statement)} \\
    &\mid \texttt{return}(e) \quad \text{(return)} \\
    &\mid \texttt{for}\ (x\ \texttt{in}\ e)\ \{\ s\ \} \quad \text{(for loop)} \\
    &\mid \texttt{while}\ (e)\ \{\ s\ \} \quad \text{(while loop)}
\end{align*}

\paragraph{Parameter Definitions}
\begin{align*}
p ::= &\ x: \tau \quad \text{(required parameter)} \\
    &\mid x: \tau = e \quad \text{(parameter with default)} \\
    &\mid \ldots \quad \text{(varargs)}
\end{align*}

\subsection{Lexical Elements}

The language uses the following lexical tokens:

\begin{itemize}
    \item \textbf{Keywords:} \texttt{function}, \texttt{if}, \texttt{else}, \texttt{for}, \texttt{in}, \texttt{while}, \texttt{return}
    \item \textbf{Type keywords:} \texttt{int}, \texttt{double}, \texttt{void}, \texttt{logical}, \texttt{vector}
    \item \textbf{Operators:}
    \begin{itemize}
        \item Assignment: \texttt{<-} (assignment), \texttt{<<-} (super-assignment)
        \item Arithmetic: \texttt{+}, \texttt{-}, \texttt{*}, \texttt{/}, \texttt{\%\%} (modulo)
        \item Comparison: \texttt{==}, \texttt{!=}, \texttt{<}, \texttt{<=}, \texttt{>}, \texttt{>=}
        \item Logical: \texttt{\&} (and), \texttt{|} (or), \texttt{!} (not)
        \item Range: num1 \texttt{:} num2 (sequence generation)
        \item Type annotation: \texttt{:} (in declaration context)
        \item Function arrow: \texttt{->} (in type signatures)
    \end{itemize}
    \item \textbf{Delimiters:} \texttt{(}, \texttt{)}, \texttt{\{}, \texttt{\}}, \texttt{[}, \texttt{]}, \texttt{,}
    \item \textbf{Literals:} Numeric literals, logical literals (\texttt{TRUE}, \texttt{FALSE})
    \item \textbf{Identifiers:} Alphanumeric sequences starting with a letter or underscore
    \item \textbf{Special:} \texttt{...} (varargs placeholder)
\end{itemize}

\section{Type System}
The type system ensures type safety through static analysis while supporting type inference to maintain concise syntax
and ease of development. 
Though it's important to note that there are many programs where type inference will fail to identify the type and our
compiler won't work due to lack of type information.

\begin{align*}
\tau ::= & \; num \mid \texttt{void} && \text{(base type)} \\
       | & \; \tau\texttt{[]} && \text{(vector type)} \\
       | & \; (\tau_1, \ldots, \tau_n) \to \tau && \text{(function type)} \\[0.5em]
num    ::= & \; \texttt{int} \mid \texttt{double} \mid \texttt{bool} && \text{(numeric types)}
\end{align*}

\paragraph{Primitive Types}

The language provides the following primitive types:

\begin{itemize}
    \item \texttt{int}: 32-bit signed integers (maps to WebAssembly \texttt{i32})
    \item \texttt{double}: 64-bit floating-point numbers (maps to WebAssembly \texttt{f64})
    \item \texttt{logical}: Boolean values (\texttt{TRUE} or \texttt{FALSE})
    \item \texttt{void}: Absence of value (used for functions with no return)
\end{itemize}
\paragraph{Logical}
Logicals will be represented as \texttt{int32} in WebAssembly, as it doesn't provide explicit type for logicals there.


\paragraph{Composite Types}

\subparagraph{Vector Types}

Vectors are homogeneous arrays parameterized by element type:

\begin{lstlisting}[language=R, caption={Vector type examples}]
# Vector of integers
v1: vector<int> <- c(1, 2, 3)

# Vector of doubles
v2: vector<double> <- c(1.5, 2.5, 3.5)

# Vector operations (component-wise)
v3: vector<double> <- v2 + c(1.0, 2.0, 3.0)
\end{lstlisting}

Vectors support component-wise arithmetic operations when both operands have compatible vector types.

\subparagraph{Function Types}

Function types represent callable values with parameter and return types:

\begin{verbatim}
<type> ::= <function_type>

<function_type> ::= <param_list> "->" <type>
                  | <primary_type>

<param_list> ::= <primary_type>
               | <primary_type> "," <param_list>

<primary_type> ::= <builtin_type>
                 | <generic_type>
                 | "(" <function_type> ")"
                 | "function"

<builtin_type> ::= "int" | "double" | "string" | "char"
                 | "void" | "logical" | "any"

<generic_type> ::= "vector" "<" <type> ">"
                 | "list" "<" <type> ">"
\end{verbatim}

Examples of function types:
\begin{itemize}
    \item \texttt{int -> int}: Function taking an integer, returning an integer
    \item \texttt{int, int -> double}: Function taking two integers, returning a double
    \item \texttt{(int -> int) -> int}: Higher-order function taking a function as parameter
    \item \texttt{int, (int, int -> int) -> int}: Function taking an integer and a function
\end{itemize}

\subsection{Type Checking}

The type checker performs bidirectional type inference:

\begin{itemize}
    \item \textbf{Bottom-up inference:} Expression types are inferred from literal values and operator signatures
    \item \textbf{Top-down checking:} Function return types and variable annotations provide expected types
    \item \textbf{Unification:} Type constraints are solved to determine concrete types
\end{itemize}

Type annotations are required in the following contexts:
\begin{itemize}
    \item Function parameters
    \item Function return types (when not inferrable from return statements)
    \item Ambiguous variable declarations
\end{itemize}

Example: \texttt{3 + 2.5} evaluates as \texttt{3.0 + 2.5 = 5.5} after promoting \texttt{3} to \texttt{double}.

\begin{figure}[htbp]
\centering
\begin{tikzpicture}[
    node distance=0.4cm,
    every node/.style={font=\small},
    astnode/.style={rectangle, draw, minimum width=2.2cm, minimum height=0.7cm, align=center, fill=gray!5},
    typenode/.style={ellipse, draw, fill=blue!15, minimum width=1.8cm, minimum height=0.6cm, align=center, font=\small\ttfamily},
    constraint/.style={rectangle, rounded corners, draw, fill=orange!15, minimum width=3cm, minimum height=0.6cm, align=center, font=\footnotesize},
    arrow/.style={->, >=stealth, thick},
    typearrow/.style={->, >=stealth, dashed, blue, thick},
    checkarrow/.style={->, >=stealth, red!70, thick}
]

% Title
\node[font=\bfseries] at (0, 4.2) {Type Checking: \texttt{a: double <- 3.5}};

% AST Nodes
\node[astnode] (assign) at (0, 3) {Assignment\\$\texttt{a} \leftarrow$};
\node[astnode] (decl) at (-3, 1.8) {Variable\\Declaration: \texttt{a}};
\node[astnode] (literal) at (3, 1.8) {Literal\\Expression: \texttt{3.5}};

% Type annotations
\node[typenode] (decltype) at (-3, 0.6) {double};
\node[typenode] (littype) at (3, 0.6) {double};

% Connections
\draw[arrow] (assign) -- (decl);
\draw[arrow] (assign) -- (literal);

% Type inference (bottom-up)
\draw[typearrow] (literal) -- node[right, font=\scriptsize, text=blue!70] {infer} (littype);

% Type annotation (top-down)
\draw[typearrow] (decl) -- node[left, font=\scriptsize, text=blue!70] {annotate} (decltype);

% Unification
\node[constraint] (unify) at (0, 0.6) {Unification Check};
\draw[checkarrow] (decltype) -- (unify);
\draw[checkarrow] (littype) -- (unify);

% Success indicator
\node[constraint, fill=green!20] (success) at (0, -0.4) { Type Check Passes: \texttt{double = double}};
\draw[arrow, green!70!black, thick] (unify) -- (success);

% Step-by-step annotation boxes
\node[anchor=west, font=\scriptsize, align=left, draw, rounded corners, fill=yellow!10, minimum width=4.5cm] at (5, 3) {
\textbf{Step 1: Top-down}\\
Parse annotation \texttt{a: double}\\
Expected type: \texttt{double}
};

\node[anchor=west, font=\scriptsize, align=left, draw, rounded corners, fill=yellow!10, minimum width=4.5cm] at (5, 1.5) {
\textbf{Step 2: Bottom-up}\\
Infer literal \texttt{3.5}\\
Inferred type: \texttt{double}
};

\node[anchor=west, font=\scriptsize, align=left, draw, rounded corners, fill=yellow!10, minimum width=4.5cm] at (5, 0) {
\textbf{Step 3: Unify}\\
Check: \texttt{double} $\stackrel{?}{=}$ \texttt{double}\\
Result: \textcolor{green!70!black}{\textbf{Success!}}
};

% Legend
\node[font=\scriptsize\bfseries, anchor=west] at (-5, -1.3) {Legend:};
\draw[arrow] (-5, -1.7) -- (-4.2, -1.7) node[anchor=west, font=\scriptsize] {AST structure};
\draw[typearrow] (-5, -2.1) -- (-4.2, -2.1) node[anchor=west, font=\scriptsize] {Type flow};
\draw[checkarrow] (-5, -2.5) -- (-4.2, -2.5) node[anchor=west, font=\scriptsize] {Unification};

\end{tikzpicture}
\caption{Bidirectional type checking for variable assignment. The type annotation \texttt{double} provides the expected type (top-down), while the literal \texttt{3.5} has its type inferred as \texttt{double} (bottom-up). The unification step verifies that both types match, allowing the assignment to proceed.}
\label{fig:type-checking-simple}
\end{figure}

\paragraph{Type Promotion}: When operands have different numeric types, implicit casting promotes to the wider type:
\begin{align*}
\text{int} \oplus \text{double} &\to \text{double} \\
\text{logical} \oplus \text{int} &\to \text{int} \\
\text{logical} \oplus \text{double} &\to \text{double}
\end{align*}
\textit{More complicated examples will be shown on compiler implementation section}

\subsection{Typing Rules}
We formalize Rty's type system using typing judgments of the form $\Gamma \vdash e : \tau$, read as ``under environment $\Gamma$, expression $e$ has type $\tau$.''
Note that our typing system employs standard concept from theory\cite{types_and_pl}. Here, we'll 
only extend on nuances.

\paragraph{Typing Contexts}
\[
\Gamma ::= \emptyset \mid \Gamma, x:\tau
\]

\paragraph{Subtyping (for numeric promotion)}
\[
\frac{}{\texttt{int} <: \texttt{int}} \qquad \frac{}{\texttt{double} <: \texttt{double}} \qquad \frac{}{\texttt{int} <: \texttt{double}}
\]

\subsection{Core Typing Rules}

\begin{mathpar}
\inferrule*[right=T-Var]
    {x:\tau \in \Gamma}
    {\Gamma \vdash x : \tau}

\and

\inferrule*[right=T-Int]
    {\ }
    {\Gamma \vdash n : \texttt{int}}

\and

\inferrule*[right=T-Double]
    {\ }
    {\Gamma \vdash d : \texttt{double}}

\and

\inferrule*[right=T-Func]
    {\Gamma, x_1:\tau_1, \ldots, x_n:\tau_n \vdash e : \tau}
    {\Gamma \vdash \texttt{function}(x_1:\tau_1, \ldots, x_n:\tau_n):\tau\ \{\ e\ \} : \tau_1,\ldots,\tau_n \to \tau}

\and

\inferrule*[right=T-App]
    {\Gamma \vdash e_1 : \tau_1,\ldots,\tau_n \to \tau \\ \Gamma \vdash e_2 : \tau_1 \\ \cdots \\ \Gamma \vdash e_{n+1} : \tau_n}
    {\Gamma \vdash e_1(e_2, \ldots, e_{n+1}) : \tau}

\and

\inferrule*[right=T-Vector]
    {\Gamma \vdash e_1 : \tau \\ \cdots \\ \Gamma \vdash e_n : \tau}
    {\Gamma \vdash \texttt{c}(e_1, \ldots, e_n) : \texttt{vector}\langle\tau\rangle}

\and

\inferrule*[right=T-AddInt]
    {\Gamma \vdash e_1 : \texttt{int} \\ \Gamma \vdash e_2 : \texttt{int}}
    {\Gamma \vdash e_1 + e_2 : \texttt{int}}

\and

\inferrule*[right=T-AddPromo]
    {\Gamma \vdash e_1 : \tau_1 \\ \Gamma \vdash e_2 : \tau_2 \\ \tau_1 <: \texttt{double} \lor \tau_2 <: \texttt{double}}
    {\Gamma \vdash e_1 + e_2 : \texttt{double}}

\and

\inferrule*[right=T-VecAdd]
    {\Gamma \vdash e_1 : \texttt{vector}\langle\tau\rangle \\ \Gamma \vdash e_2 : \texttt{vector}\langle\tau\rangle}
    {\Gamma \vdash e_1 + e_2 : \texttt{vector}\langle\tau\rangle}

\and

\inferrule*[right=T-Assign]
    {\Gamma \vdash e : \tau \\ \Gamma' = \Gamma, x:\tau}
    {\Gamma \vdash x \gets e : \tau}

\and

\inferrule*[right=T-SuperAssign]
    {\Gamma \vdash e : \tau \\ x:\tau \in \Gamma_i \text{ for some } i < |\Gamma|}
    {\Gamma \vdash x \ll\gets e : \tau}
\end{mathpar}


\paragraph{Conditionals}

\[
\frac{\Gamma \vdash e_{cond} : \texttt{logical} \quad \Gamma \vdash e_{then} : T \quad \Gamma \vdash e_{else} : T}{\Gamma \vdash \texttt{if}\ (e_{cond})\ \{ e_{then} \}\ \texttt{else}\ \{ e_{else} \} : T}
\]

If-expressions require a logical condition and both branches must have the same type.

\subsection{Scoping and Closures}

The language uses lexical scoping where:
\begin{itemize}
    \item Only functions create new scopes (blocks, if-statements, and loops do not)
    \item Functions can capture variables from enclosing function scopes
    \item Captured variables are implemented using closure environments in WebAssembly
    \item Super-assignment (\texttt{<<-}) searches enclosing function scopes to modify variables
\end{itemize}

Example demonstrating closure:
\begin{lstlisting}[language=R, caption={Closure example}]
make_counter <- function(start: int): () -> int {
    count <- start
    function(): int {
        count <<- count + 1
        return(count)
    }
}

counter <- make_counter(0)
print(counter())  # Prints 1
print(counter())  # Prints 2
\end{lstlisting}




\section{Semantics}

This section describes the operational semantics of key language constructs.

\subsection{Expression Evaluation}

Expression evaluation follows a small-step operational semantics with evaluation contexts.

\paragraph{Literal Evaluation}

Literals evaluate to themselves:
\begin{align*}
n &\Downarrow n \quad \text{(numeric literal)} \\
\texttt{"str"} &\Downarrow \texttt{"str"} \quad \text{(string literal)} \\
\texttt{TRUE} &\Downarrow \texttt{TRUE} \quad \text{(logical literal)}
\end{align*}

\paragraph{Variable Lookup}

Variable references evaluate by environment lookup:
\[
\frac{\rho(x) = v}{\langle x, \rho \rangle \Downarrow v}
\]
where $\rho$ is the runtime environment mapping identifiers to values.

\paragraph{Binary Operations}

Binary operations evaluate operands left-to-right, then apply the operation:
\[
\frac{\langle e_1, \rho \rangle \Downarrow v_1 \quad \langle e_2, \rho \rangle \Downarrow v_2 \quad v_1 \oplus v_2 = v}{\langle e_1 \oplus e_2, \rho \rangle \Downarrow v}
\]
where $\oplus$ represents any binary operator.

\textbf{Arithmetic Operators} (\texttt{+}, \texttt{-}, \texttt{*}, \texttt{/}, \texttt{\%\%}) on same types:
\begin{align*}
n_1 + n_2 &= n_1 + n_2 \quad \text{(int + int $\to$ int)} \\
d_1 + d_2 &= d_1 + d_2 \quad \text{(double + double $\to$ double)} \\
n_1 - n_2 &= n_1 - n_2 \\
n_1 * n_2 &= n_1 \times n_2 \\
n_1 / n_2 &= \lfloor n_1 \div n_2 \rfloor \quad \text{(integer division)} \\
d_1 / d_2 &= d_1 \div d_2 \quad \text{(floating-point division)} \\
n_1 \bmod n_2 &= n_1 \bmod n_2
\end{align*}

\textbf{Comparison Operators} (\texttt{==}, \texttt{!=}, \texttt{<}, \texttt{<=}, \texttt{>}, \texttt{>=}) produce logical values:
\begin{align*}
n_1 < n_2 &= \texttt{TRUE} \text{ if } n_1 < n_2, \text{ else } \texttt{FALSE} \\
n_1 == n_2 &= \texttt{TRUE} \text{ if } n_1 = n_2, \text{ else } \texttt{FALSE}
\end{align*}
Type promotion applies: \texttt{3 < 2.5} compares as \texttt{3.0 < 2.5}.

\textbf{Logical Operators} (\texttt{\&}, \texttt{|}) on boolean values:
\begin{align*}
b_1 \texttt{ \& } b_2 &= b_1 \land b_2 \\
b_1 \texttt{ | } b_2 &= b_1 \lor b_2
\end{align*}

\textbf{Vector Operations} are applied component-wise after ensuring compatible types:
\[
\texttt{vector}[v_1, \ldots, v_n] \oplus \texttt{vector}[w_1, \ldots, w_n] = \texttt{vector}[v_1 \oplus w_1, \ldots, v_n \oplus w_n]
\]

For mixed vector types, element types are promoted (e.g., \texttt{vector<int>} + \texttt{vector<double>} produces \texttt{vector<double>}).

\textbf{Vector-Scalar Operations}: Scalars are broadcast to match vector length:
\[
\texttt{vector}[v_1, \ldots, v_n] \oplus s = \texttt{vector}[v_1 \oplus s, \ldots, v_n \oplus s]
\]


\paragraph{Function Application}

Function application evaluates the callee to obtain a closure, evaluates arguments, extends the closure environment, and evaluates the body:
\[
\frac{
\begin{aligned}
&\langle e_0, \rho \rangle \Downarrow \langle \lambda(x_1, \ldots, x_n).e, \rho' \rangle \\
&\langle e_1, \rho \rangle \Downarrow v_1 \quad \cdots \quad \langle e_n, \rho \rangle \Downarrow v_n \\
&\langle e, \rho'[x_1 \mapsto v_1, \ldots, x_n \mapsto v_n] \rangle \Downarrow v
\end{aligned}
}{
\langle e_0(e_1, \ldots, e_n), \rho \rangle \Downarrow v
}
\]

\subsection{Statement Execution}

Statements modify the environment and may alter control flow.

\paragraph{Assignment}

Assignment evaluates the right-hand side and binds the result to the identifier:
\[
\frac{\langle e, \rho \rangle \Downarrow v}{\langle x \texttt{ <- } e, \rho \rangle \rightarrow \rho[x \mapsto v]}
\]

Super-assignment searches parent scopes:
\[
\frac{\langle e, \rho \rangle \Downarrow v \quad x \in \text{dom}(\rho_{parent})}{\langle x \texttt{ <<- } e, \rho \rangle \rightarrow \rho[\rho_{parent}[x \mapsto v]]}
\]

\paragraph{Conditional Execution}

If-statements evaluate the condition and execute the appropriate branch:
\[
\frac{\langle e_{cond}, \rho \rangle \Downarrow \texttt{TRUE} \quad \langle s_{then}, \rho \rangle \rightarrow \rho'}{\langle \texttt{if}\ (e_{cond})\ \{ s_{then} \}, \rho \rangle \rightarrow \rho'}
\]

\[
\frac{\langle e_{cond}, \rho \rangle \Downarrow \texttt{FALSE} \quad \langle s_{else}, \rho \rangle \rightarrow \rho'}{\langle \texttt{if}\ (e_{cond})\ \{ s_{then} \}\ \texttt{else}\ \{ s_{else} \}, \rho \rangle \rightarrow \rho'}
\]

\paragraph{While Loops}

While loops repeatedly execute the body while the condition is true:
\[
\frac{\langle e_{cond}, \rho \rangle \Downarrow \texttt{FALSE}}{\langle \texttt{while}\ (e_{cond})\ \{ s \}, \rho \rangle \rightarrow \rho}
\]

\[
\frac{
\begin{aligned}
&\langle e_{cond}, \rho \rangle \Downarrow \texttt{TRUE} \\
&\langle s, \rho \rangle \rightarrow \rho' \\
&\langle \texttt{while}\ (e_{cond})\ \{ s \}, \rho' \rangle \rightarrow \rho''
\end{aligned}
}{
\langle \texttt{while}\ (e_{cond})\ \{ s \}, \rho \rangle \rightarrow \rho''
}
\]

\paragraph{For Loops}

For loops iterate over vectors or ranges:
\[
\frac{
\begin{aligned}
&\langle e_{vec}, \rho \rangle \Downarrow \texttt{vector}[v_1, \ldots, v_n] \\
&\langle s, \rho[x \mapsto v_1] \rangle \rightarrow \rho_1 \\
&\cdots \\
&\langle s, \rho_{n-1}[x \mapsto v_n] \rangle \rightarrow \rho_n
\end{aligned}
}{
\langle \texttt{for}\ (x\ \texttt{in}\ e_{vec})\ \{ s \}, \rho \rangle \rightarrow \rho_n
}
\]

\subsection{Function Calls and Return}

Function calls push a new activation frame onto the call stack. The \texttt{return} statement terminates function execution and yields a value:
\[
\frac{\langle e, \rho \rangle \Downarrow v}{\langle \texttt{return}(e), \rho \rangle \Rightarrow v}
\]

The special $\Rightarrow$ arrow indicates early exit from the function body.

\subsection{Built-in Functions}

The language provides built-in functions with special semantics:

\begin{itemize}
    \item \texttt{c(e1, ..., en)}: Creates a vector from arguments. All arguments must have the same type.
    \item \texttt{print(e)}: Outputs the value of expression \texttt{e} to standard output.
    \item \texttt{length(v)}: Returns the number of elements in vector \texttt{v}.
    \item \texttt{sum(v)}: Returns the sum of all elements in numeric vector \texttt{v}.
    \item \texttt{gen\_seq(start, end)}: Generates a sequence from \texttt{start} to \texttt{end} (equivalent to \texttt{start:end}).
\end{itemize}
