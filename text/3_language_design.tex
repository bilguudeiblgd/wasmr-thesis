
\chapter{Language Design and Mappings}
In this chapter, we'll design a subset of R with types and see how types and their operations could map to WASM generation.
\section{Design Goals}
To design typed R, I tried to be as close as possible to R semantics to easily compile available R codes with wasmR. Although there are obviously inherent limitations compiling dynamic language to statically typed bytecode. Issues include mutability, typing, reflections. For example, how do we deal with

\begin{verbatim}
var <- 21  // assign integer
print(var)
var <- c(1,2,3) // assign vector
\end{verbatim}

This is a perfectly fine code for R but compiling it to WASM brings difficulties. Therefore, like other static languages, we will add checking against mutability of different types. 

\begin{itemize}
    \item R compatibility: Preserve R's syntax and core semantics where possible
    \item Type safety: Static type checking with sound type system
    \item Ahead-of-time compilation
    \item A single executable WASM file, no linking required
    \item First-class functions: Support functional programming with closures
    \item Practicality: Provide essential functions for data processing (builtins)
\end{itemize}

\section{Typed R-like Language}
This section presents the design of a statically-typed programming language inspired by R's syntax, which we refer to as the \textit{Typed R-like Language}. The language maintains R's characteristic features such as the left-assignment operator (\texttt{<-}), first-class functions, and vector-oriented programming, while introducing a static type system to enable ahead-of-time compilation to WebAssembly.

The language supports:
\begin{itemize}
    \item \textbf{Static typing} with type inference and explicit type annotations
    \item \textbf{First-class functions} with closures and lexical scoping
    \item \textbf{Vector operations} as a fundamental data structure
    \item \textbf{Control flow} constructs including conditionals and loops
    \item \textbf{Higher-order functions} enabling functional programming patterns
    \item \textbf{Lexical scoping} with support for nested functions and variable capture
    \item \textbf{Named arguments} enabling option to have positional and optional arguments
\end{itemize}

The design philosophy emphasizes a familiar R-like syntax while ensuring type safety and efficient compilation to WebAssembly. Unlike dynamically-typed R, all type information is resolved at compile time, enabling optimized code generation and early error detection.

\section{Syntax}

The syntax of the Typed R-like Language closely follows R conventions with extensions for explicit type annotations. This section describes the core syntactic constructs.

\begin{align*}
e ::= & \; x && \text{(variable)} \\
    | & \; n && \text{(literal)} \\
    | & \; e_1 \; \textit{op} \; e_2 && \text{(binary operation)} \\
    | & \; \textit{op} \; e_1 && \text{(unary operation)} \\
    | & \; \texttt{if} \; e_1 \; \texttt{then} \; e_2 \; \texttt{else} \; e_3 && \text{(conditional)} \\
    | & \; \texttt{fun}(x : \tau) \to e && \text{(function)} \\
    | & \; e_1(e_2) && \text{(application)}
\end{align*}

\subsection{Lexical Elements}

The language uses the following lexical tokens:

\begin{itemize}
    \item \textbf{Keywords:} \texttt{function}, \texttt{if}, \texttt{else}, \texttt{for}, \texttt{in}, \texttt{while}, \texttt{return}
    \item \textbf{Type keywords:} \texttt{int}, \texttt{double}, \texttt{string}, \texttt{char}, \texttt{void}, \texttt{logical}, \texttt{any}, \texttt{vector}, \texttt{list}
    \item \textbf{Operators:}
    \begin{itemize}
        \item Assignment: \texttt{<-} (assignment), \texttt{<<-} (super-assignment)
        \item Arithmetic: \texttt{+}, \texttt{-}, \texttt{*}, \texttt{/}, \texttt{\%\%} (modulo)
        \item Comparison: \texttt{==}, \texttt{!=}, \texttt{<}, \texttt{<=}, \texttt{>}, \texttt{>=}
        \item Logical: \texttt{\&} (and), \texttt{|} (or), \texttt{!} (not)
        \item Range: \texttt{:} (sequence generation)
        \item Type annotation: \texttt{:} (in declaration context)
        \item Function arrow: \texttt{->} (in type signatures)
    \end{itemize}
    \item \textbf{Delimiters:} \texttt{(}, \texttt{)}, \texttt{\{}, \texttt{\}}, \texttt{[}, \texttt{]}, \texttt{,}
    \item \textbf{Literals:} Numeric literals, string literals (double-quoted), logical literals (\texttt{TRUE}, \texttt{FALSE})
    \item \textbf{Identifiers:} Alphanumeric sequences starting with a letter or underscore
    \item \textbf{Special:} \texttt{...} (varargs placeholder)
\end{itemize}


\subsection{Variable Declaration and Assignment}

Variables are declared using the left-assignment operator with optional type annotations:

\begin{lstlisting}[language=Python, caption={Variable assignment examples}]
# Simple assignment with type inference
x <- 10

# Assignment with explicit type annotation
y: int <- 20

# Vector assignment
vec <- c(1, 2, 3)
\end{lstlisting}

\begin{lstlisting}[caption={Variable assignment in WAT}]
(module
  ;; Define array type for vectors
  (type $vec_i32 (array (mut i32)))
  
  (func $main
    (local $x i32)
    (local $y i32)
    (local $vec (ref null $vec_i32))
    
    ;; x <- 10
    i32.const 10
    local.set $x
    
    ;; y: int <- 20
    i32.const 20
    local.set $y
    
    ;; vec <- c(1, 2, 3)
    i32.const 1
    i32.const 2
    i32.const 3
    i32.const 3
    array.new_fixed $vec_i32 3
    local.set $vec
  )
  
  (start $main)
)
\end{lstlisting}

The super-assignment operator \texttt{<<-} modifies variables in enclosing function scopes:

\begin{lstlisting}[language=R, caption={Super-assignment example}]
outer <- function() {
    x <- 0
    inner <- function() {
        x <<- 10  # Modifies x in outer scope
    }
    inner()
    return(x)  # Returns 10
}
\end{lstlisting}
\textit{This takes certain workaround to compile it in WASM. We'll talk about its 
compilation in further chapters.}


\subsection{Function Definitions}

Functions are first-class values defined using the \texttt{function} keyword:

\begin{lstlisting}[language=R, caption={Function definition examples in typed R}]
# Simple function with type annotations
add <- function(a: int, b: int): int {
    return(a + b)
}

# Function returning a vector
create_vector <- function(): vector<double> {
    return(c(1.0, 2.0, 3.0))
}

# Higher-order function
apply_twice <- function(f: int -> int, x: int): int {
    return(f(f(x)))
}

\end{lstlisting}

\begin{lstlisting}[caption={Function definition examples in WAT}]
(module
  ;; Define array type for double vectors
  (type $vec_f64 (array (mut f64)))
  
  ;; add <- function(a: int, b: int): int
  (func $add (param $a i32) (param $b i32) (result i32)
    local.get $a
    local.get $b
    i32.add
  )
  
  ;; create_vector <- function(): vector<double>
  (func $create_vector (result (ref $vec_f64))
    f64.const 1.0
    f64.const 2.0
    f64.const 3.0
    i32.const 3
    array.new_fixed $vec_f64 3
  )
  ;; apply_twice is not shown here.
  
)
\end{lstlisting}

Function types use arrow notation: \texttt{param\_types -> return\_type}. Multiple parameters are comma-separated, and parentheses group complex function types when used as parameters.

\subsection{Control Flow}

\subsubsection{Conditional Statements}

The language supports \texttt{if-else} statements and expressions:

\begin{lstlisting}[language=R, caption={Conditional examples in typed R}]
# If statement
if (x > 0) {
    print(x)
}

# If-else statement
if (x > 0) {
    y <- 1
} else {
    y <- -1
}

# If expression (returns value)
result <- if (x > 0) { 1 } else { -1 }
\end{lstlisting}

\begin{lstlisting}[caption={Conditional examples in WAT}]
(module
  ;; Import print function from host environment
  (import "env" "print" (func $print (param i32)))
  
  (func $main
    (local $x i32)
    (local $y i32)
    
    ;; Set x to some value for demonstration
    i32.const 5
    local.set $x
    
    ;; if (x > 0) { print(x) }
    local.get $x
    i32.const 0
    i32.gt_s              ;; x > 0 (signed comparison)
    if
      local.get $x
      call $print
    end
    
    ;; if (x > 0) { y <- 1 } else { y <- -1 }
    local.get $x
    i32.const 0
    i32.gt_s              ;; x > 0
    if
      i32.const 1
      local.set $y
    else
      i32.const -1
      local.set $y
    end
  )
  
  (start $main)
)
\end{lstlisting}

\subsubsection{Loops}

Two loop constructs are provided: \texttt{for} and \texttt{while}.

\begin{lstlisting}[language=R, caption={Loop examples}]
# For loop iterating over range
for (i in 1:10) {
    print(i)
}

# For loop iterating over vector
vec <- c(1, 2, 3, 4, 5)
for (x in vec) {
    print(x)
}

# While loop
i <- 1
sum <- 0
while (i <= 5) {
    sum <- sum + i
    i <- i + 1
}
\end{lstlisting}

\begin{lstlisting}[caption={While loop examples in WAT}]
(module
  (func $main
    (local $i i32)
    (local $sum i32)
    
    ;; i <- 1
    i32.const 1
    local.set $i
    
    ;; sum <- 0
    i32.const 0
    local.set $sum
    
    ;; while (i <= 5) { ... }
    (block $break
      (loop $continue
        ;; Check condition: i <= 5
        local.get $i
        i32.const 5
        i32.le_s            ;; i <= 5 (signed comparison)
        i32.eqz             ;; negate: if NOT (i <= 5)
        br_if $break        ;; break if condition is false
        
        ;; sum <- sum + i
        local.get $sum
        local.get $i
        i32.add
        local.set $sum
        
        ;; i <- i + 1
        local.get $i
        i32.const 1
        i32.add
        local.set $i
        
        ;; Continue loop
        br $continue
      )
    )
  )
  
  (start $main)
)
\end{lstlisting}

\subsection{Expressions}

The language supports various expression forms:

\begin{itemize}
    \item \textbf{Literals:} \texttt{42L}, \texttt{3} \texttt{3.14}, \texttt{TRUE}, \texttt{FALSE}
    \item \textbf{Identifiers:} Variable references
    \item \textbf{Binary operations:} Arithmetic, comparison, logical, range (\texttt{1:10})
    \item \textbf{Unary operations:} Negation (\texttt{-x}), logical not (\texttt{!x})
    \item \textbf{Function calls:} \texttt{f(arg1, arg2)} with positional or named arguments
    \item \textbf{Vector indexing:} \texttt{vec[i]}
    \item \textbf{Vector construction:} \texttt{c(1, 2, 3)}
    \item \textbf{Function definitions:} Anonymous functions as expressions
    \item \textbf{If expressions:} Conditional expressions returning values
\end{itemize}


\subsection{Blocks and Tail Expressions}

Blocks consist of zero or more statements followed by an optional tail expression. The tail expression (final expression without semicolon) determines the block's value:

\begin{lstlisting}[language=R, caption={Block with tail expression}]
f <- function(x: int): int {
    y <- x * 2
    z <- y + 1
    z  # Tail expression - returned automatically
}
\end{lstlisting}



\section{Type System}
The type system ensures type safety through static analysis while supporting type inference to maintain concise syntax. 
Though it's important to note that there are many programs where type inference will fail to identify the type and our
compiler won't work due to lack of type information. (reference needed as to why type inference is hard)

\begin{align*}
\tau ::= & \; num \mid \texttt{void} && \text{(base type)} \\
       | & \; \tau\texttt{[]} && \text{(vector type)} \\
       | & \; (\tau_1, \ldots, \tau_n) \to \tau && \text{(function type)} \\[0.5em]
num    ::= & \; \texttt{int} \mid \texttt{double} \mid \texttt{bool} && \text{(numeric types)}
\end{align*}

\subsection{Primitive Types}

The language provides the following primitive types:

\begin{itemize}
    \item \texttt{int}: 32-bit signed integers (maps to WebAssembly \texttt{i32})
    \item \texttt{double}: 64-bit floating-point numbers (maps to WebAssembly \texttt{f64})
    \item \texttt{logical}: Boolean values (\texttt{TRUE} or \texttt{FALSE})
    \item \texttt{void}: Absence of value (used for functions with no return)
\end{itemize}
\paragraph{Logical}
Logicals will be represented as \texttt{int32} in WebAssembly, as it doesn't provide explicit type for logicals there.


\subsection{Composite Types}

\subsubsection{Vector Types}

Vectors are homogeneous arrays parameterized by element type:

\begin{lstlisting}[language=R, caption={Vector type examples}]
# Vector of integers
v1: vector<int> <- c(1, 2, 3)

# Vector of doubles
v2: vector<double> <- c(1.5, 2.5, 3.5)

# Vector operations (component-wise)
v3: vector<double> <- v2 + c(1.0, 2.0, 3.0)
\end{lstlisting}

Vectors support component-wise arithmetic operations when both operands have compatible vector types.

\subsubsection{Function Types}

Function types represent callable values with parameter and return types:

\begin{verbatim}
<type> ::= <function_type>

<function_type> ::= <param_list> "->" <type>
                  | <primary_type>

<param_list> ::= <primary_type>
               | <primary_type> "," <param_list>

<primary_type> ::= <builtin_type>
                 | <generic_type>
                 | "(" <function_type> ")"
                 | "function"

<builtin_type> ::= "int" | "double" | "string" | "char"
                 | "void" | "logical" | "any"

<generic_type> ::= "vector" "<" <type> ">"
                 | "list" "<" <type> ">"
\end{verbatim}

Examples of function types:
\begin{itemize}
    \item \texttt{int -> int}: Function taking an integer, returning an integer
    \item \texttt{int, int -> double}: Function taking two integers, returning a double
    \item \texttt{(int -> int) -> int}: Higher-order function taking a function as parameter
    \item \texttt{int, (int, int -> int) -> int}: Function taking an integer and a function
\end{itemize}

\subsection{Type Inference}

The type checker performs bidirectional type inference:

\begin{itemize}
    \item \textbf{Bottom-up inference:} Expression types are inferred from literal values and operator signatures
    \item \textbf{Top-down checking:} Function return types and variable annotations provide expected types
    \item \textbf{Unification:} Type constraints are solved to determine concrete types
\end{itemize}

Type annotations are required in the following contexts:
\begin{itemize}
    \item Function parameters
    \item Function return types (when not inferrable from return statements)
    \item Ambiguous variable declarations
\end{itemize}

\subsection{Typing Rules}

Selected typing rules are presented below using inference rule notation.

\subsubsection{Variable Reference}

\[
\frac{\Gamma(x) = T}{\Gamma \vdash x : T}
\]

A variable reference has the type bound in the environment $\Gamma$.

\subsubsection{Function Application}

\[
\frac{\Gamma \vdash e_1 : T_1, \ldots, T_n \to T \quad \Gamma \vdash e_2 : T_1 \quad \cdots \quad \Gamma \vdash e_{n+1} : T_n}{\Gamma \vdash e_1(e_2, \ldots, e_{n+1}) : T}
\]

Function application checks that argument types match parameter types and produces the return type.

\subsubsection{Function Definition}

\[
\frac{\Gamma, x_1:T_1, \ldots, x_n:T_n \vdash e : T_{ret}}{\Gamma \vdash \texttt{function}(x_1:T_1, \ldots, x_n:T_n): T_{ret} \{ e \} : (T_1, \ldots, T_n \to T_{ret})}
\]

A function definition has a function type where parameters and return type match the declared signature.

\subsubsection{Binary Operations}

\[
\frac{\Gamma \vdash e_1 : \texttt{int} \quad \Gamma \vdash e_2 : \texttt{int}}{\Gamma \vdash e_1 + e_2 : \texttt{int}}
\]

\[
\frac{\Gamma \vdash e_1 : \texttt{double} \quad \Gamma \vdash e_2 : \texttt{double}}{\Gamma \vdash e_1 + e_2 : \texttt{double}}
\]

Arithmetic operators are overloaded for numeric types. Comparison operators produce \texttt{logical} values.

\subsubsection{Vector Operations}

\[
\frac{\Gamma \vdash e_1 : \texttt{vector}<T> \quad \Gamma \vdash e_2 : \texttt{vector}<T>}{\Gamma \vdash e_1 + e_2 : \texttt{vector}<T>}
\]

Component-wise vector operations require matching element types.

\subsubsection{Conditionals}

\[
\frac{\Gamma \vdash e_{cond} : \texttt{logical} \quad \Gamma \vdash e_{then} : T \quad \Gamma \vdash e_{else} : T}{\Gamma \vdash \texttt{if}\ (e_{cond})\ \{ e_{then} \}\ \texttt{else}\ \{ e_{else} \} : T}
\]

If-expressions require a logical condition and both branches must have the same type.

\subsection{Scoping and Closures}

The language uses lexical scoping where:
\begin{itemize}
    \item Only functions create new scopes (blocks, if-statements, and loops do not)
    \item Functions can capture variables from enclosing function scopes
    \item Captured variables are implemented using closure environments in WebAssembly
    \item Super-assignment (\texttt{<<-}) searches enclosing function scopes to modify variables
\end{itemize}

Example demonstrating closure:
\begin{lstlisting}[language=R, caption={Closure example}]
make_counter <- function(start: int): () -> int {
    count <- start
    function(): int {
        count <<- count + 1
        return(count)
    }
}

counter <- make_counter(0)
print(counter())  # Prints 1
print(counter())  # Prints 2
\end{lstlisting}




\section{Semantics}

This section describes the operational semantics of key language constructs.

\subsection{Expression Evaluation}

Expression evaluation follows a small-step operational semantics with evaluation contexts.

\subsubsection{Literal Evaluation}

Literals evaluate to themselves:
\begin{align*}
n &\Downarrow n \quad \text{(numeric literal)} \\
\texttt{"str"} &\Downarrow \texttt{"str"} \quad \text{(string literal)} \\
\texttt{TRUE} &\Downarrow \texttt{TRUE} \quad \text{(logical literal)}
\end{align*}

\subsubsection{Variable Lookup}

Variable references evaluate by environment lookup:
\[
\frac{\rho(x) = v}{\langle x, \rho \rangle \Downarrow v}
\]
where $\rho$ is the runtime environment mapping identifiers to values.

\subsubsection{Binary Operations}

Binary operations evaluate operands left-to-right, then apply the operation:
\[
\frac{\langle e_1, \rho \rangle \Downarrow v_1 \quad \langle e_2, \rho \rangle \Downarrow v_2 \quad v_1 \oplus v_2 = v}{\langle e_1 \oplus e_2, \rho \rangle \Downarrow v}
\]
where $\oplus$ represents any binary operator.

\textbf{Arithmetic Operators} (\texttt{+}, \texttt{-}, \texttt{*}, \texttt{/}, \texttt{\%\%}) on same types:
\begin{align*}
n_1 + n_2 &= n_1 + n_2 \quad \text{(int + int $\to$ int)} \\
d_1 + d_2 &= d_1 + d_2 \quad \text{(double + double $\to$ double)} \\
n_1 - n_2 &= n_1 - n_2 \\
n_1 * n_2 &= n_1 \times n_2 \\
n_1 / n_2 &= \lfloor n_1 \div n_2 \rfloor \quad \text{(integer division)} \\
d_1 / d_2 &= d_1 \div d_2 \quad \text{(floating-point division)} \\
n_1 \bmod n_2 &= n_1 \bmod n_2
\end{align*}

\textbf{Type Promotion}: When operands have different numeric types, implicit casting promotes to the wider type:
\begin{align*}
\text{int} \oplus \text{double} &\to \text{double} \\
\text{logical} \oplus \text{int} &\to \text{int} \\
\text{logical} \oplus \text{double} &\to \text{double}
\end{align*}

Example: \texttt{3 + 2.5} evaluates as \texttt{3.0 + 2.5 = 5.5} after promoting \texttt{3} to \texttt{double}.

\textbf{Comparison Operators} (\texttt{==}, \texttt{!=}, \texttt{<}, \texttt{<=}, \texttt{>}, \texttt{>=}) produce logical values:
\begin{align*}
n_1 < n_2 &= \texttt{TRUE} \text{ if } n_1 < n_2, \text{ else } \texttt{FALSE} \\
n_1 == n_2 &= \texttt{TRUE} \text{ if } n_1 = n_2, \text{ else } \texttt{FALSE}
\end{align*}
Type promotion applies: \texttt{3 < 2.5} compares as \texttt{3.0 < 2.5}.

\textbf{Logical Operators} (\texttt{\&}, \texttt{|}) on boolean values:
\begin{align*}
b_1 \texttt{ \& } b_2 &= b_1 \land b_2 \\
b_1 \texttt{ | } b_2 &= b_1 \lor b_2
\end{align*}

\textbf{Vector Operations} are applied component-wise after ensuring compatible types:
\[
\texttt{vector}[v_1, \ldots, v_n] \oplus \texttt{vector}[w_1, \ldots, w_n] = \texttt{vector}[v_1 \oplus w_1, \ldots, v_n \oplus w_n]
\]

For mixed vector types, element types are promoted (e.g., \texttt{vector<int>} + \texttt{vector<double>} produces \texttt{vector<double>}).

\textbf{Vector-Scalar Operations}: Scalars are broadcast to match vector length:
\[
\texttt{vector}[v_1, \ldots, v_n] \oplus s = \texttt{vector}[v_1 \oplus s, \ldots, v_n \oplus s]
\]


\subsubsection{Function Application}

Function application evaluates the callee to obtain a closure, evaluates arguments, extends the closure environment, and evaluates the body:
\[
\frac{
\begin{aligned}
&\langle e_0, \rho \rangle \Downarrow \langle \lambda(x_1, \ldots, x_n).e, \rho' \rangle \\
&\langle e_1, \rho \rangle \Downarrow v_1 \quad \cdots \quad \langle e_n, \rho \rangle \Downarrow v_n \\
&\langle e, \rho'[x_1 \mapsto v_1, \ldots, x_n \mapsto v_n] \rangle \Downarrow v
\end{aligned}
}{
\langle e_0(e_1, \ldots, e_n), \rho \rangle \Downarrow v
}
\]

\subsection{Statement Execution}

Statements modify the environment and may alter control flow.

\subsubsection{Assignment}

Assignment evaluates the right-hand side and binds the result to the identifier:
\[
\frac{\langle e, \rho \rangle \Downarrow v}{\langle x \texttt{ <- } e, \rho \rangle \rightarrow \rho[x \mapsto v]}
\]

Super-assignment searches parent scopes:
\[
\frac{\langle e, \rho \rangle \Downarrow v \quad x \in \text{dom}(\rho_{parent})}{\langle x \texttt{ <<- } e, \rho \rangle \rightarrow \rho[\rho_{parent}[x \mapsto v]]}
\]

\subsubsection{Conditional Execution}

If-statements evaluate the condition and execute the appropriate branch:
\[
\frac{\langle e_{cond}, \rho \rangle \Downarrow \texttt{TRUE} \quad \langle s_{then}, \rho \rangle \rightarrow \rho'}{\langle \texttt{if}\ (e_{cond})\ \{ s_{then} \}, \rho \rangle \rightarrow \rho'}
\]

\[
\frac{\langle e_{cond}, \rho \rangle \Downarrow \texttt{FALSE} \quad \langle s_{else}, \rho \rangle \rightarrow \rho'}{\langle \texttt{if}\ (e_{cond})\ \{ s_{then} \}\ \texttt{else}\ \{ s_{else} \}, \rho \rangle \rightarrow \rho'}
\]

\subsubsection{While Loops}

While loops repeatedly execute the body while the condition is true:
\[
\frac{\langle e_{cond}, \rho \rangle \Downarrow \texttt{FALSE}}{\langle \texttt{while}\ (e_{cond})\ \{ s \}, \rho \rangle \rightarrow \rho}
\]

\[
\frac{
\begin{aligned}
&\langle e_{cond}, \rho \rangle \Downarrow \texttt{TRUE} \\
&\langle s, \rho \rangle \rightarrow \rho' \\
&\langle \texttt{while}\ (e_{cond})\ \{ s \}, \rho' \rangle \rightarrow \rho''
\end{aligned}
}{
\langle \texttt{while}\ (e_{cond})\ \{ s \}, \rho \rangle \rightarrow \rho''
}
\]

\subsubsection{For Loops}

For loops iterate over vectors or ranges:
\[
\frac{
\begin{aligned}
&\langle e_{vec}, \rho \rangle \Downarrow \texttt{vector}[v_1, \ldots, v_n] \\
&\langle s, \rho[x \mapsto v_1] \rangle \rightarrow \rho_1 \\
&\cdots \\
&\langle s, \rho_{n-1}[x \mapsto v_n] \rangle \rightarrow \rho_n
\end{aligned}
}{
\langle \texttt{for}\ (x\ \texttt{in}\ e_{vec})\ \{ s \}, \rho \rangle \rightarrow \rho_n
}
\]

\subsection{Function Calls and Return}

Function calls push a new activation frame onto the call stack. The \texttt{return} statement terminates function execution and yields a value:
\[
\frac{\langle e, \rho \rangle \Downarrow v}{\langle \texttt{return}(e), \rho \rangle \Rightarrow v}
\]

The special $\Rightarrow$ arrow indicates early exit from the function body.

\subsection{Built-in Functions}

The language provides built-in functions with special semantics:

\begin{itemize}
    \item \texttt{c(e1, ..., en)}: Creates a vector from arguments. All arguments must have the same type.
    \item \texttt{print(e)}: Outputs the value of expression \texttt{e} to standard output.
    \item \texttt{length(v)}: Returns the number of elements in vector \texttt{v}.
    \item \texttt{sum(v)}: Returns the sum of all elements in numeric vector \texttt{v}.
    \item \texttt{gen\_seq(start, end)}: Generates a sequence from \texttt{start} to \texttt{end} (equivalent to \texttt{start:end}).
\end{itemize}
