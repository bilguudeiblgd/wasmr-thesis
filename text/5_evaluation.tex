
\chapter{Evaluation}
\section{Correctness}
The compiler includes comprehensive tests across multiple dimensions:

\paragraph{Unit Tests:}
Units tests are by far easiest to write but still essential to any piece of software.
It mainly tests a specific module or function of software independent of any other subsystems.
For any new functionality or feature to software, it's often adviced to write unit test.
\begin{itemize}
    \item Lexer: Token stream validation (\texttt{tests/lexer\_tests.rs})
    \item Parser: AST structure correctness (\texttt{tests/parser\_tests.rs})
    \item Type resolution: Type inference and error detection (\texttt{tests/ir\_builtin\_tests.rs}, \texttt{tests/ir\_scoping\_tests.rs})
    \item First-class functions: Higher-order function type checking (\texttt{tests/first\_class\_function\_tests.rs})
\end{itemize}

\paragraph{Integration Tests:}
\begin{itemize}
    \item WASM generation: Smoke tests for code emission (\texttt{tests/wasm\_codegen\_smoke.rs})
    \item End-to-end: Compilation and execution (\texttt{tests/wasm\_write\_out.rs})
\end{itemize}

\paragraph{Validation Tests (\texttt{./test.sh}):}
Most important suite of test where I wrote many R typed code programs each having 
a print line in the end as result of some computation or environment changes.

\begin{itemize}
    \item 40+ example programs in \texttt{data/} covering:
    \begin{itemize}
        \item Basic arithmetic and control flow
        \item Vector operations and indexing
        \item Function definitions and calls
        \item Closures with captures
        \item Superassignment scenarios
        \item Named arguments and defaults
        \item Edge cases and error conditions
    \end{itemize}
\end{itemize}

\textbf{Cross-validation (\texttt{./translate\_and\_test.sh}):}

Our end-to-end validation process ensures semantic equivalence between Rty and R by comparing outputs from both execution paths. Figure~\ref{fig:validation} illustrates this dual-path testing strategy.

\begin{figure}[h]
\centering
\resizebox{\textwidth}{!}{%
\begin{tikzpicture}[
    node distance=1.2cm and 0.8cm,
    box/.style={rectangle, draw, fill=blue!10, text width=2.2cm, align=center, minimum height=0.9cm, rounded corners, font=\small},
    process/.style={rectangle, draw, fill=green!10, text width=2.2cm, align=center, minimum height=0.9cm, font=\small},
    output/.style={rectangle, draw, fill=orange!10, text width=1.5cm, align=center, minimum height=0.7cm, font=\small},
    decision/.style={diamond, draw, fill=yellow!10, text width=1.5cm, align=center, aspect=2, font=\small},
    arrow/.style={-{Stealth[length=2mm]}, thick},
    dashedarrow/.style={-{Stealth[length=2mm]}, thick, dashed}
]

% Input
\node[box, fill=cyan!20] (input) {Typed R Code\\{\scriptsize\texttt{data/*.R}}};

% Top path (Rty compiler)
\node[process, right=of input] (compiler) {wasmR Compiler\\{\scriptsize Type Check}};
\node[box, right=of compiler] (wasm) {WASM\\{\scriptsize\texttt{.wasm}}};
\node[process, right=of wasm] (wasmtime) {Execute\\{\scriptsize wasmtime}};
\node[output, right=of wasmtime] (output1) {Output 1};

% Bottom path (R interpreter)
\node[process, below=2.5cm of compiler] (erasure) {Type Erasure\\{\scriptsize Remove types}};
\node[box, right=of erasure] (untypedr) {R code};
\node[process, right=of untypedr] (rinterp) {Execute\\{\scriptsize Rscript}};
\node[output, right=of rinterp] (output2) {Output 2};

% Comparison
\node[decision, below right=1cm and -0.5cm of output1] (compare) {Match};

% Arrows - top path
\draw[arrow] (input) -- (compiler);
\draw[arrow] (compiler) -- (wasm);
\draw[arrow] (wasm) -- (wasmtime);
\draw[arrow] (wasmtime) -- (output1);
\draw[arrow] (output1) -- (compare);

% Arrows - bottom path
\draw[arrow] (input) -- (erasure);
\draw[arrow] (erasure) -- (untypedr);
\draw[arrow] (untypedr) -- (rinterp);
\draw[arrow] (rinterp) -- (output2);
\draw[arrow] (output2) -- (compare);

% Path labels
\node[above=0.15cm of compiler, font=\footnotesize\bfseries, color=blue!70] {Compilation Path};
\node[below=0.15cm of erasure, font=\footnotesize\bfseries, color=blue!70] {Interpretation Path};

\end{tikzpicture}
}
\caption{End-to-end validation test architecture. Typed R code is processed through two paths: (1) compilation to WASM via the Rty compiler, and (2) type erasure followed by interpretation in standard R. Outputs are compared to ensure semantic equivalence.}
\label{fig:validation}
\end{figure}

This validation approach:
\begin{itemize}
    \item Compares Rty output against native R for compatible programs
    \item Validates semantic equivalence for core features
    \item Ensures type annotations don't alter program behavior
    \item Provides confidence in compiler correctness through differential testing
\end{itemize}


\subsection{Type Safety}

We provide an informal argument for type soundness:

\begin{claim}[Progress]
If $\vdash e : \tau$, then either $e$ is a value or $e \to e'$ for some $e'$.
\end{claim}

\textbf{Sketch:} By induction on typing derivations. Each well-typed expression is either:
\begin{itemize}
    \item A value (literals, closures, vectors)
    \item Reducible by one of the reduction rules
    \item The type system ensures all required subexpressions are well-typed
\end{itemize}

\begin{claim}[Preservation]
If $\Gamma \vdash e : \tau$ and $e \to e'$, then $\Gamma \vdash e' : \tau$.
\end{claim}

\textbf{Sketch:} By induction on reduction rules. Each reduction preserves types:
\begin{itemize}
    \item $\beta$-reduction: Substitution lemma ensures type preservation
    \item Arithmetic: Operations preserve numeric types per typing rules
    \item Vector operations: Element types maintained through construction/indexing
\end{itemize}

\textbf{WASM Type Validation:}
The generated WASM is validated by \texttt{wasmtime --validate}, confirming:
\begin{itemize}
    \item All type indices are valid
    \item Stack discipline is maintained
    \item Reference types are used correctly
    \item Struct accesses are within bounds
\end{itemize}

\section{Performance}

\subsection{Compilation Time}

Measured on Apple M1 (8-core, 16GB RAM):

\begin{table}[htbp]
\centering
\begin{tabular}{lrr}
\toprule
\textbf{Program} & \textbf{Lines} & \textbf{Compile Time (ms)} \\
\midrule
\texttt{basic/arithmetic.R} & 5 & 74 \\
\texttt{functions/factorial.R} & 13 & 71 \\
\texttt{closures/counter.R} & 18 & 74 \\
\texttt{vectors/operations.R} & 8 & 73 \\
Full suite (43 files) & 460 & 69 \\
\bottomrule
\end{tabular}
\caption{Compilation time benchmarks}
\end{table}

Compilation is fast enough for interactive development workflows.

\subsection{Runtime Performance}

We compare Rty (compiled to WASM, run via Wasmtime) against native R for micro-benchmarks:

\textbf{Methodology:}
\begin{itemize}
    \item Each benchmark run 5 times after 2 warmup runs, average reported
    \item R version: 4.3.1
    \item Wasmtime version: 16.0.0 with GC enabled
    \item Hardware: Apple M3 Max, macOS 26.3
\end{itemize}

\textbf{Results:}

\begin{table}[htbp]
\centering
\begin{tabular}{lrrr}
\toprule
\textbf{Benchmark} & \textbf{R (ms)} & \textbf{Rty/WASM (ms)} & \textbf{Speedup} \\
\midrule
Integer sum (10k elements) & 155 & 57 & 2.71$\times$ \\
Vector addition (10k) & 155 & 57 & 2.71$\times$ \\
Recursive Fibonacci(25) & 185 & 57 & 3.24$\times$ \\
Nested loops (1M iterations) & 183 & 65 & 2.81$\times$ \\
Closure creation (10k) & 154 & 59 & 2.61$\times$ \\
\bottomrule
\end{tabular}
\caption{Runtime performance benchmarks}
\end{table}

\textbf{Analysis:}
\begin{itemize}
    \item Rty shows consistent speedups (2.6--3.2$\times$) over interpreted R
    \item Performance is competitive with compiled languages
    \item WASM GC overhead is minimal for typical workloads
    \item Vector operations benefit from static types and inlining
\end{itemize}

\textbf{Limitations:}
\begin{itemize}
    \item R's highly optimized built-ins (e.g., \texttt{sum()}, \texttt{mean()}) not yet matched
    \item Large vector allocations may be slower due to WASM GC
    \item No SIMD vectorization yet (future work)
\end{itemize}

\section{Discussion}
The performance boost, compared to standard R environment and WebR, should be taken with a grain of salt.
First of all, they deal with more complexity. NA/NULL types for example. It'd lead to wrapping the data with
structured objects like tagged union and each operation will need to work with structs than primitive types.
This leads to performance tradeoffs in runtime. Although, we can use more syntax sugar,
annotating that some types can allow NA/NULL with symbols like \texttt{int?, int!}, so that we can
use primitive types instead of struct types in WASM. This will indeed keep our performance more or so the same.

Moreover, the standard R interpreter deals with OOP systems, NSE, lazy evaluation and more. Implementing these 
would most likely, lower our performance a bit. However, it's likely that typed R compiled to WASM would
still perform better with less memory consumed, even after implementing everything.

\subsection{Results}

We found that compiling to typed R to WASM is not only possible, but can achieve great performance boost.
Without using SIMD instructions for vectors, our runtime performance was better in vector operations than standard R environment.
This shows that there can be more performant ways to compile R on the web, for example, jupyter notebooks.

Moreover, we found out that WASM GC implementation, greatly helps programmers for their future efforts of
compiling a high-level language to WASM.
(to be added more)

\subsection{Limitations}

However, as research states, coming up with type system for R is of great difficulty\cite{R_towards_type_system}.
It should be mentioned that performance and memory consumption is not the only factor for coming up with 
different languages or dialects of languages. Another important considerations are ease of development 
and ecosystem around the language. Adding annotation to R, could increase performance on the web environment,
and increase trust in programs\cite{R_towards_type_system}, but it could also take away the ease of development.
(to be detailed further)

\subsection{Future Work}

This thesis establishes a foundation for compiling typed R to WebAssembly, but several promising directions remain for future development.

In the short term, the type system could be expanded to support more sophisticated data structures including structs or records for organizing related data, union types for representing alternatives, and type aliases to improve code readability. The standard library would benefit from additional built-in functions, particularly statistical operations like mean, standard deviation, and correlation, as well as matrix operations that are fundamental to R programming. The compiler pipeline could be enhanced with standard optimization passes such as constant folding, dead code elimination, and function inlining to improve generated code quality. Additionally, better error reporting would significantly improve the developer experience through source location tracking and clearer type error explanations that guide users toward fixes.

Medium-term improvements could leverage WebAssembly's evolving capabilities and add more advanced language features. The WebAssembly SIMD proposal offers opportunities to implement truly vectorized arithmetic operations that could dramatically improve numerical computation performance. Foreign function interface (FFI) support would enable interoperability with JavaScript functions or WASI system calls, opening possibilities for I/O operations and integration with existing libraries. Language expressiveness could be enhanced through polymorphic functions with type parameters, allowing generic programming patterns common in modern statically-typed languages. Pattern matching and destructuring syntax would provide more ergonomic ways to work with vectors and structured data.

Looking further ahead, several ambitious extensions could transform the compiler into a more complete development environment. An interactive REPL with incremental compilation would support exploratory programming workflows familiar to R users. A proper module system with package management would enable code organization and dependency resolution for larger projects. Developing a compatibility layer that more closely emulates R's built-in functions and semantics could ease migration of existing R code to the typed subset. Finally, adding alternative compilation backends targeting LLVM or Cranelift would enable native code generation alongside WebAssembly, potentially offering even better performance for compute-intensive applications while maintaining the portability benefits of the WebAssembly target.

\subsection{Related Work}

\textbf{Type Systems for Dynamic Languages:}
\begin{itemize}
    \item \textbf{TypeScript} (JavaScript): Gradual typing with structural types
    \item \textbf{Typed Racket}: Occurrence typing and gradual typing for Scheme
    \item \textbf{Reticulated Python}: Runtime-enforced gradual typing
    \item \textbf{Our approach}: Fully static typing with R syntax
\end{itemize}

\textbf{R Type Systems:}
\begin{itemize}
    \item \textbf{typed-R}: Annotations for documentation, not enforced
    \item \textbf{RTypeInference}: Static analysis tool, no compilation
    \item \textbf{Å˜}: Experimental typed R dialect (discontinued)
    \item \textbf{Our contribution}: First statically typed R-like language targeting WASM
\end{itemize}

\textbf{Functional Language Compilation to WASM:}
\begin{itemize}
    \item \textbf{AssemblyScript} (TypeScript-like): Static types, but JavaScript semantics
    \item \textbf{Grain}: ML-like language with WASM GC
    \item \textbf{OCaml/wasm}: OCaml backend for WASM
    \item \textbf{Our approach}: R syntax with closures and mutable captures via reference cells
\end{itemize}

\chapter{Conclusion}

This thesis presented Rty, a statically typed R-like language that compiles to WebAssembly. We demonstrated that:

\begin{enumerate}
    \item \textbf{R's core features are amenable to static typing}: Vector operations, lexical scoping, and first-class functions can be efficiently compiled with type safety guarantees.

    \item \textbf{WASM GC enables high-level language features}: Structural subtyping for closures and automatic memory management make WASM a viable compilation target for functional languages.

    \item \textbf{Reference cells provide a principled approach to mutable captures}: R's superassignment can be implemented in a statically typed setting using explicit reference types.

    \item \textbf{Performance improvements are significant}: Ahead-of-time compilation to WASM provides 2.6--3.2$\times$ speedups over interpreted R for typical workloads.
\end{enumerate}

The Rty compiler demonstrates that combining R's intuitive syntax with static types and modern compilation techniques produces a practical language for performance-critical data processing tasks. The system's clean architecture and comprehensive test suite provide a foundation for future extensions.

\textbf{Key contributions:}
\begin{itemize}
    \item Formal type system for R-like language with first-class functions
    \item Novel closure compilation strategy using WASM GC subtyping
    \item Reference cell technique for statically typed mutable captures
    \item Working compiler implementation with $\sim$8,500 lines of Rust
\end{itemize}

Rty shows that static typing and R-like syntax are compatible, opening possibilities for safer and faster data science tools that leverage WebAssembly's portability and performance.
