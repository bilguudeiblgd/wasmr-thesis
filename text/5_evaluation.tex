
\chapter{Evaluation}
\section{Correctness}
The compiler includes comprehensive tests across multiple dimensions:

\paragraph{Unit Tests:}
Units tests are by far easiest to write but still essential to any piece of software.
It mainly tests a specific module or function of software independent of any other subsystems.
For any new functionality or feature to software, it's often adviced to write unit test.
\begin{itemize}
    \item Lexer: Token stream validation (\texttt{tests/lexer\_tests.rs})
    \item Parser: AST structure correctness (\texttt{tests/parser\_tests.rs})
    \item Type resolution: Type inference and error detection (\texttt{tests/ir\_builtin\_tests.rs}, \texttt{tests/ir\_scoping\_tests.rs})
    \item First-class functions: Higher-order function type checking (\texttt{tests/first\_class\_function\_tests.rs})
\end{itemize}

\paragraph{Integration Tests:}
\begin{itemize}
    \item WASM generation: Smoke tests for code emission (\texttt{tests/wasm\_codegen\_smoke.rs})
    \item End-to-end: Compilation and execution (\texttt{tests/wasm\_write\_out.rs})
\end{itemize}

\paragraph{Validation Tests (\texttt{./test.sh}):}
Most important suite of test where I wrote many R typed code programs each having 
a print line in the end as result of some computation or environment changes.

\begin{itemize}
    \item 40+ example programs in \texttt{data/} covering:
    \begin{itemize}
        \item Basic arithmetic and control flow
        \item Vector operations and indexing
        \item Function definitions and calls
        \item Closures with captures
        \item Superassignment scenarios
        \item Named arguments and defaults
        \item Edge cases and error conditions
    \end{itemize}
\end{itemize}

\textbf{Cross-validation (\texttt{./translate\_and\_test.sh}):}

Our end-to-end validation process ensures semantic equivalence between Rty and R by comparing outputs from both execution paths. Figure~\ref{fig:validation} illustrates this dual-path testing strategy.

\begin{figure}[h]
\centering
\resizebox{\textwidth}{!}{%
\begin{tikzpicture}[
    node distance=1.2cm and 0.8cm,
    box/.style={rectangle, draw, fill=blue!10, text width=2.2cm, align=center, minimum height=0.9cm, rounded corners, font=\small},
    process/.style={rectangle, draw, fill=green!10, text width=2.2cm, align=center, minimum height=0.9cm, font=\small},
    output/.style={rectangle, draw, fill=orange!10, text width=1.5cm, align=center, minimum height=0.7cm, font=\small},
    decision/.style={diamond, draw, fill=yellow!10, text width=1.5cm, align=center, aspect=2, font=\small},
    arrow/.style={-{Stealth[length=2mm]}, thick},
    dashedarrow/.style={-{Stealth[length=2mm]}, thick, dashed}
]

% Input
\node[box, fill=cyan!20] (input) {Typed R Code\\{\scriptsize\texttt{data/*.R}}};

% Top path (Rty compiler)
\node[process, right=of input] (compiler) {wasmR Compiler\\{\scriptsize Type Check}};
\node[box, right=of compiler] (wasm) {WASM\\{\scriptsize\texttt{.wasm}}};
\node[process, right=of wasm] (wasmtime) {Execute\\{\scriptsize wasmtime}};
\node[output, right=of wasmtime] (output1) {Output 1};

% Bottom path (R interpreter)
\node[process, below=2.5cm of compiler] (erasure) {Type Erasure\\{\scriptsize Remove types}};
\node[box, right=of erasure] (untypedr) {R code};
\node[process, right=of untypedr] (rinterp) {Execute\\{\scriptsize Rscript}};
\node[output, right=of rinterp] (output2) {Output 2};

% Comparison
\node[decision, below right=1cm and -0.5cm of output1] (compare) {Match};

% Arrows - top path
\draw[arrow] (input) -- (compiler);
\draw[arrow] (compiler) -- (wasm);
\draw[arrow] (wasm) -- (wasmtime);
\draw[arrow] (wasmtime) -- (output1);
\draw[arrow] (output1) -- (compare);

% Arrows - bottom path
\draw[arrow] (input) -- (erasure);
\draw[arrow] (erasure) -- (untypedr);
\draw[arrow] (untypedr) -- (rinterp);
\draw[arrow] (rinterp) -- (output2);
\draw[arrow] (output2) -- (compare);

% Path labels
\node[above=0.15cm of compiler, font=\footnotesize\bfseries, color=blue!70] {Compilation Path};
\node[below=0.15cm of erasure, font=\footnotesize\bfseries, color=blue!70] {Interpretation Path};

\end{tikzpicture}
}
\caption{End-to-end validation test architecture. Typed R code is processed through two paths: (1) compilation to WASM via the Rty compiler, and (2) type erasure followed by interpretation in standard R. Outputs are compared to ensure semantic equivalence.}
\label{fig:validation}
\end{figure}

This validation approach:
\begin{itemize}
    \item Compares Rty output against native R for compatible programs
    \item Validates semantic equivalence for core features
    \item Ensures type annotations don't alter program behavior
    \item Provides confidence in compiler correctness through differential testing
\end{itemize}


\subsection{Type Safety}

We provide an informal argument for type soundness:

\begin{claim}[Progress]
If $\vdash e : \tau$, then either $e$ is a value or $e \to e'$ for some $e'$.
\end{claim}

\textbf{Sketch:} By induction on typing derivations. Each well-typed expression is either:
\begin{itemize}
    \item A value (literals, closures, vectors)
    \item Reducible by one of the reduction rules
    \item The type system ensures all required subexpressions are well-typed
\end{itemize}

\begin{claim}[Preservation]
If $\Gamma \vdash e : \tau$ and $e \to e'$, then $\Gamma \vdash e' : \tau$.
\end{claim}

\textbf{Sketch:} By induction on reduction rules. Each reduction preserves types:
\begin{itemize}
    \item $\beta$-reduction: Substitution lemma ensures type preservation
    \item Arithmetic: Operations preserve numeric types per typing rules
    \item Vector operations: Element types maintained through construction/indexing
\end{itemize}

\textbf{WASM Type Validation:}
The generated WASM is validated by \texttt{wasmtime --validate}, confirming:
\begin{itemize}
    \item All type indices are valid
    \item Stack discipline is maintained
    \item Reference types are used correctly
    \item Struct accesses are within bounds
\end{itemize}

\section{Performance}

\subsection{Compilation Time}

Measured on Apple M1 (8-core, 16GB RAM):

\begin{table}[htbp]
\centering
\begin{tabular}{lrr}
\toprule
\textbf{Program} & \textbf{Lines} & \textbf{Compile Time (ms)} \\
\midrule
\texttt{basic/arithmetic.R} & 5 & 74 \\
\texttt{functions/factorial.R} & 13 & 71 \\
\texttt{closures/counter.R} & 18 & 74 \\
\texttt{vectors/operations.R} & 8 & 73 \\
Full suite (43 files) & 460 & 69 \\
\bottomrule
\end{tabular}
\caption{Compilation time benchmarks}
\end{table}

Compilation is fast enough for interactive development workflows.

\subsection{Runtime Performance}

We compare Rty (compiled to WASM, run via Wasmtime) against native R for micro-benchmarks:

\textbf{Methodology:}
\begin{itemize}
    \item Each benchmark run 5 times after 2 warmup runs, average reported
    \item R version: 4.3.1
    \item Wasmtime version: 16.0.0 with GC enabled
    \item Hardware: Apple M3 Max, macOS 26.3
\end{itemize}

\textbf{Results:}

\begin{table}[htbp]
\centering
\begin{tabular}{lrrr}
\toprule
\textbf{Benchmark} & \textbf{R (ms)} & \textbf{Rty/WASM (ms)} & \textbf{Speedup} \\
\midrule
Integer sum (10k elements) & 155 & 57 & 2.71$\times$ \\
Vector addition (10k) & 155 & 57 & 2.71$\times$ \\
Recursive Fibonacci(25) & 185 & 57 & 3.24$\times$ \\
Nested loops (1M iterations) & 183 & 65 & 2.81$\times$ \\
Closure creation (10k) & 154 & 59 & 2.61$\times$ \\
\bottomrule
\end{tabular}
\caption{Runtime performance benchmarks}
\end{table}

\textbf{Analysis:}
\begin{itemize}
    \item Rty shows consistent speedups (2.6--3.2$\times$) over interpreted R
    \item Performance is competitive with compiled languages
    \item WASM GC overhead is minimal for typical workloads
    \item Vector operations benefit from static types and inlining
\end{itemize}

\textbf{Limitations:}
\begin{itemize}
    \item R's highly optimized built-ins (e.g., \texttt{sum()}, \texttt{mean()}) not yet matched
    \item Large vector allocations may be slower due to WASM GC
    \item No SIMD vectorization yet (future work)
\end{itemize}

\section{Discussion}

\subsection{Achievements}

\textbf{Type System:}
\begin{itemize}
    \item Sound static type system with polymorphic vectors
    \item First-class functions with structural typing
    \item Support for R's superassignment in a statically typed setting
\end{itemize}

\textbf{Compiler:}
\begin{itemize}
    \item Clean multi-stage architecture with IR passes
    \item Novel use of WASM GC subtyping for closures
    \item Efficient reference cell strategy for mutable captures
\end{itemize}

\textbf{Language Features:}
\begin{itemize}
    \item R-compatible syntax with type annotations
    \item Named arguments and default values
    \item Lexical scoping matching R semantics
\end{itemize}

\subsection{Limitations}

\textbf{Language Coverage:}
\begin{itemize}
    \item No support for R's non-standard evaluation (NSE)
    \item Missing advanced features: environments, formulas, S3/S4 objects
    \item Limited built-in function library compared to R
    \item No interoperability with R packages
\end{itemize}

\textbf{Type System:}
\begin{itemize}
    \item Parametric polymorphism limited to vectors (no generic functions)
    \item No type inference for function parameters (must be annotated)
    \item Subtyping only for numeric promotion
\end{itemize}

\textbf{Performance:}
\begin{itemize}
    \item WASM GC still maturing; some overhead compared to manual memory management
    \item Vector operations not yet SIMD-optimized
    \item No lazy evaluation (R uses promises extensively)
\end{itemize}

\textbf{Tooling:}
\begin{itemize}
    \item No REPL or interactive mode
    \item Limited error messages compared to mature compilers
    \item No IDE integration or language server
\end{itemize}

\subsection{Future Work}

\textbf{Short-term:}
\begin{enumerate}
    \item \textbf{Expand type system}: Add structs/records, union types, type aliases
    \item \textbf{More built-ins}: Statistical functions (mean, sd, cor), matrix operations
    \item \textbf{Optimization passes}: Constant folding, dead code elimination, inlining
    \item \textbf{Better errors}: Source location tracking, type error explanations
\end{enumerate}

\textbf{Medium-term:}
\begin{enumerate}
    \item \textbf{SIMD vectors}: Use WASM SIMD proposal for vectorized arithmetic
    \item \textbf{Interop}: FFI to JavaScript or WASI for I/O and libraries
    \item \textbf{Polymorphism}: Generic functions with type parameters
    \item \textbf{Pattern matching}: Destructuring for vectors and structured data
\end{enumerate}

\textbf{Long-term:}
\begin{enumerate}
    \item \textbf{REPL}: Interactive mode with incremental compilation
    \item \textbf{Package system}: Module system and dependency management
    \item \textbf{R compatibility layer}: Emulate R built-ins and semantics more closely
    \item \textbf{Native backend}: LLVM or Cranelift for native code generation
\end{enumerate}

\subsection{Related Work}

\textbf{Type Systems for Dynamic Languages:}
\begin{itemize}
    \item \textbf{TypeScript} (JavaScript): Gradual typing with structural types
    \item \textbf{Typed Racket}: Occurrence typing and gradual typing for Scheme
    \item \textbf{Reticulated Python}: Runtime-enforced gradual typing
    \item \textbf{Our approach}: Fully static typing with R syntax
\end{itemize}

\textbf{R Type Systems:}
\begin{itemize}
    \item \textbf{typed-R}: Annotations for documentation, not enforced
    \item \textbf{RTypeInference}: Static analysis tool, no compilation
    \item \textbf{Å˜}: Experimental typed R dialect (discontinued)
    \item \textbf{Our contribution}: First statically typed R-like language targeting WASM
\end{itemize}

\textbf{Functional Language Compilation to WASM:}
\begin{itemize}
    \item \textbf{AssemblyScript} (TypeScript-like): Static types, but JavaScript semantics
    \item \textbf{Grain}: ML-like language with WASM GC
    \item \textbf{OCaml/wasm}: OCaml backend for WASM
    \item \textbf{Our approach}: R syntax with closures and mutable captures via reference cells
\end{itemize}

\chapter{Conclusion}

This thesis presented Rty, a statically typed R-like language that compiles to WebAssembly. We demonstrated that:

\begin{enumerate}
    \item \textbf{R's core features are amenable to static typing}: Vector operations, lexical scoping, and first-class functions can be efficiently compiled with type safety guarantees.

    \item \textbf{WASM GC enables high-level language features}: Structural subtyping for closures and automatic memory management make WASM a viable compilation target for functional languages.

    \item \textbf{Reference cells provide a principled approach to mutable captures}: R's superassignment can be implemented in a statically typed setting using explicit reference types.

    \item \textbf{Performance improvements are significant}: Ahead-of-time compilation to WASM provides 2.6--3.2$\times$ speedups over interpreted R for typical workloads.
\end{enumerate}

The Rty compiler demonstrates that combining R's intuitive syntax with static types and modern compilation techniques produces a practical language for performance-critical data processing tasks. The system's clean architecture and comprehensive test suite provide a foundation for future extensions.

\textbf{Key contributions:}
\begin{itemize}
    \item Formal type system for R-like language with first-class functions
    \item Novel closure compilation strategy using WASM GC subtyping
    \item Reference cell technique for statically typed mutable captures
    \item Working compiler implementation with $\sim$8,500 lines of Rust
\end{itemize}

Rty shows that static typing and R-like syntax are compatible, opening possibilities for safer and faster data science tools that leverage WebAssembly's portability and performance.
