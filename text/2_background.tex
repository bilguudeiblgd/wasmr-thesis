\chapter{Background}

\section{The R Programming Language}

\textbf{R} is a domain-specific language designed for statistical computing and graphics, originally developed by Ross Ihaka and Robert Gentleman in the early 1990s as an open-source implementation of the \textbf{S} language. With its CRAN package manager providing more than 20000 packages, it's a widely programming language used by industries where experimenting with data is involved, such as data analytics, data mining and bio-informatics. 

\subsection{Key Characteristics}

\begin{itemize}
  \item \textbf{Dynamic typing:} Variables have no declared types; types are determined at runtime. This enables rapid prototyping but prevents static verification and certain compiler optimizations.

  \item \textbf{Vectorization:} Operations apply element-wise to vectors, matrices, and arrays. For example,
  \[
    \texttt{c(1,2,3) + c(4,5,6)} \;\Rightarrow\; \texttt{c(5,7,9)}
  \]
  without the need for explicit loops.

  \item \textbf{Lexical scoping:} R uses lexical (static) scoping with closures. Functions capture their defining environment, enabling functional programming patterns and higher-order abstractions.

  \item \textbf{Lazy evaluation:} Function arguments are evaluated lazily (call-by-need), allowing non-standard evaluation mechanisms that support domain-specific sublanguages.

  \item \textbf{Copy-on-modify semantics:} R employs implicit copying to preserve referential transparency. While this simplifies reasoning about programs, it may introduce performance overhead in memory-intensive workloads.
\end{itemize}

\subsection{Assignment Operators}

R provides multiple assignment operators with distinct scoping behavior:

\begin{itemize}
  \item \texttt{\textless{}-}: Regular assignment in the current environment.
  \item \texttt{\textless{}\textless{}-}: Superassignment, which modifies the nearest existing binding in an enclosing environment.
\end{itemize}

\subsection{Type System}
R employs a dynamic type system with several foundational types, all of which are first-class objects. Unlike statically-typed languages, type information is associated with values at runtime rather than with variable declarations.
Atomic Types
R provides six atomic vector types:
\begin{itemize}
\item \textbf{Logical:} Boolean values \texttt{TRUE}, \texttt{FALSE}, and \texttt{NA} (missing).
\begin{verbatim}
x <- TRUE
typeof(x)      # returns "logical"
\end{verbatim}
\item \textbf{Integer:} Whole numbers, denoted with an \texttt{L} suffix.
\begin{verbatim}
x <- 42L
typeof(x)      # returns "integer"
\end{verbatim}
\item \textbf{Double:} Floating-point numbers (default numeric type).
\begin{verbatim}
x <- 3.14
typeof(x)      # returns "double"
\end{verbatim}
\item \textbf{Character:} Strings of text.
\begin{verbatim}
x <- "hello"
typeof(x)      # returns "character"
\end{verbatim}
\item \textbf{Complex:} Complex numbers with real and imaginary parts.
\begin{verbatim}
x <- 2 + 3i
typeof(x)      # returns "complex"
\end{verbatim}
\item \textbf{Raw:} Raw bytes (rarely used).
\begin{verbatim}
x <- charToRaw("A")
typeof(x)      # returns "raw"
\end{verbatim}
\end{itemize}
Composite Types
Beyond atomic vectors, R supports several composite data structures:
\begin{itemize}
\item \textbf{List:} Heterogeneous collections that can hold elements of different types.
\begin{verbatim}
x <- list(42, "text", TRUE)
typeof(x)      # returns "list"
\end{verbatim}
\item \textbf{Function:} Functions are first-class objects.
\begin{verbatim}
f <- function(x) x + 1
typeof(f)      # returns "closure"
\end{verbatim}
This means functions are treated as normal variables. It can be nested definition, passed as parameter and returned from a function.
\item \textbf{Environment:} Hash-like structures for variable scoping.
\begin{verbatim}
e <- new.env()
typeof(e)      # returns "environment"
\end{verbatim}
\end{itemize}
Type Coercion
R performs implicit type coercion following a hierarchy: logical → integer → double → character. When combining types, R automatically converts to the most general type:
\begin{verbatim}
c(TRUE, 1L, 2.5, "text")  # returns character vector:
# "TRUE" "1" "2.5" "text"
\end{verbatim}
This automatic coercion simplifies interactive use but can lead to unexpected behavior if types are not carefully managed.

\subsection{Peculiarities}
As every programming language comes with their nuances and uniqueness, R is no short of those. Below, the ones mention worthy examples


\begin{itemize}
    \item Vectors and lists are indexed by 1. For example,
    \begin{verbatim}
        v <- c(10,20,30) // initializes a vector of 10,20,30
        v[1]             // returns 10
        v[2]             // returns 20
    \end{verbatim}

    \item Even a scalar is represented as a vector of 1 element. 
    \begin{verbatim}
        x <- 5           // assign 5
        is.vector(x)     // return TRUE
    \end{verbatim}
    The reason for it is to recycle the vectors easily. The language is designed for vector operations
    \begin{verbatim}
        x <- 5           // assign 5
        v <- c(10,20,30) // initializes a vector of 10,20,30
        x + v            // returns a vector of 15,25,35
    \end{verbatim}
    
\end{itemize}


\section{WebAssembly}
WebAssembly is a low-level assembly-like language that is made to
run in modern browser\cite{mdn_webassembly}. It's designed to work together with
JavaScript, the language of the web environment, offering flexibility and performance.
Currently most modern languages support WASM as compilation target; for example, Rust through
rustc, C/C++ through Emscripten.

Practically, WebAssembly offers myriad of possibilities to developers. 
From Image-processing libraries in hidden behind C to desktop apps written in C\#, with WASM
, they can run on the web with near native-like performance. Notable examples 
of adoption of WASM are Figma\cite{figma_wasm}, Autodesk AutoCAD Web App\cite{autocad_wasm}, and Google Earth\cite{google_earth_wasm}.

Moreover, for readability, WebAssembly also has so-called Web Assembly Text Format, in short WAT.
It's a form where bytecode itself is more readable, with more syntactic sugars. Let's iterate over properties of WASM and how it's structured and written in WAT format.

\paragraph{Module system}
WebAssembly code is organized into modules. 
Modules declare imports (functions, memory, tables, globals from the host environment) 
and exports (making internal definitions available externally)\cite{wasm_specs}:
\begin{lstlisting}[caption={Module demonstrating import and export mechanisms}]
(module
  ;; Import a logging function from the host
  (import "env" "log" (func $log (param i32)))
  
  ;; Import memory from the host
  (import "env" "memory" (memory 1))
  
  ;; Internal function (not exported)
  (func $internal_add (param $a i32) (param $b i32) (result i32)
    local.get $a
    local.get $b
    i32.add
  )

  ;; Can write memory
  ;; Can create data segment
  
  ;; Public function that uses imports
  (func $add_and_log (param $a i32) (param $b i32) (result i32)
    local.get $a
    local.get $b
    call $internal_add    ;; call internal function
    local.get 0           ;; duplicate result for logging
    call $log             ;; log the result
  )
  
  ;; Export the public function
  (export "addAndLog" (func $add_and_log))
)
\end{lstlisting}

\paragraph{Stack-based machine}
With goals of being fast, efficient, and portable, WebAssembly, at its heart, is a stack-based virtual machine
running on the web. Stack-based machine in this context is a process virtual machine that works as 
virtualization of computer system on top of a computer. Its workings is primarily based on
interacting with the stack. For example:

% Center the tree diagram
\begin{figure}[h!]
  \centering
  \begin{forest}
    [\texttt{+}
      [\texttt{1}]
      [\texttt{2}]
    ]
  \end{forest}
  \caption{Tree representation}
\end{figure}

\begin{lstlisting}[caption={A simple WebAssembly function showing stack operations}]
(module
  (func $compute (result i32)
    i32.const 1       ;; push constant 1 onto stack
    i32.const 2       ;; push constant 2 onto stack
    i32.add           ;; pop two values, push sum
  )
  (export "compute" (func $compute))
)
\end{lstlisting}

\paragraph{Structured control flow}

Unlike raw bytecode with goto-style jumps, WebAssembly uses structured 
control flow constructs: block, loop, if, and br (branch). 
Each construct creates a label that branches can target.\cite{wasm_specs}

\begin{lstlisting}[caption={Conditional execution using structured control flow}]
(module
  (func $max (param $a i32) (param $b i32) (result i32)
    local.get $a
    local.get $b
    i32.gt_s              ;; signed greater-than comparison
    (if (result i32)
      (then
        local.get $a
      )
      (else
        local.get $b
      )
    )
  )
  (export "max" (func $max))
)
\end{lstlisting}


\paragraph{Linear memory model}
WebAssembly provides a contiguous, resizable array of bytes called linear memory. Memory is accessed via load/store instructions with explicit alignment and offset.\cite{wasm_specs}
\begin{lstlisting}[caption={Accessing linear memory with load and store instructions}]
(module
  (memory 1)              ;; declare 1 page (64KB) of memory
  (func $increment_at_zero
    i32.const 0           ;; memory address
    i32.const 0           ;; memory address (for load)
    i32.load              ;; load 32-bit value from address 0
    i32.const 1           ;; constant 1
    i32.add               ;; increment
    i32.store             ;; store result back to address 0
  )
  (export "memory" (memory 0))
  (export "increment" (func $increment_at_zero))
)
\end{lstlisting}

\paragraph{Type system and Determinism}
A decoded module is type-safe and checked in module instantiation. 
Moreover, WebAssembly specification fully defines
valid programs and their behaviour.\cite{wasm_specs}

\section{Previous works}
Work related to R about compilers and interpreter has been nothing but inspiring. The R
has started with what we now call Tree-Walk interpreter\cite{r_paper}. Then around April 2011, with release of R 2.13.0
come the bytecode compiler by Luke Tierney, which was written almost entirely in R\cite{r_version_213_notes}. Essentially, it's faster 
to compile R into some intermediate bytecode and then have it executed by VM\cite{tierney2019bytecode}.
Thus, standard R environment execution became either with AST interpreter or with Bytecode Compiler\cite{rbytecodebook}.
From then on all standard functions and packages in base R ws pre-compiled into bytecode. Lastly, JIT bytecode compiler 
became the default from R.3.4.1\cite{RJ-2017-1-ch}.

On top of standard implementations, execution on different environments have also been explored.
WebR\cite{webR}, most notably, is a recent work that compiles the R interpreter to WebAssembly using the Emscripten compiler 
to run R code on the web. Though as hinted at introduction, compiling the interpreter to WASM
has its tradeoffs.

In terms of type system and type annotations around the R, there has been a discussion around type system in R as well\cite{R_towards_type_system}.
There are even implementations for type system for R\cite{typr2025}, although it's not adopted by R community. However, the purpose of the thesis
is exploring the compilation of R to WASM. In that we use type annotations, but it's important to note that 
we won't dig deep into type systems at all.
